{"version":3,"file":"index.es5.js","sources":["../src/utils.ts","../src/ast.ts","../src/RewriteHandler.ts","../src/rewriters/Rewriter.ts","../src/rewriters/FieldArgNameRewriter.ts","../src/rewriters/FieldArgsToInputTypeRewriter.ts","../src/rewriters/FieldArgTypeRewriter.ts","../src/rewriters/NestFieldOutputsRewriter.ts","../src/rewriters/ScalarFieldToObjectFieldRewriter.ts","../src/rewriters/JsonToTypedObjectRewriter.ts","../src/matchConditions/fragmentMatchCondition.ts","../src/matchConditions/operationMatchCondition.ts","../src/matchConditions/queryMatchCondition.ts","../src/matchConditions/mutationMatchCondition.ts"],"sourcesContent":["/** @hidden */\nexport const identifyFunc = <T>(val: T) => val;\n\n/** @hidden */\nexport const pushToArrayAtKey = <T>(mapping: { [key: string]: T[] }, key: string, val: T): void => {\n  if (!mapping[key]) mapping[key] = [];\n  mapping[key].push(val);\n};\n","import { ASTNode, DocumentNode, FragmentDefinitionNode, VariableDefinitionNode } from 'graphql';\nimport { pushToArrayAtKey } from './utils';\n\nconst ignoreKeys = new Set(['loc']);\n\n/** @hidden */\nexport const nodesMatch = (node1: ASTNode, node2: ASTNode): boolean => {\n  for (const key of Object.keys(node1)) {\n    if (ignoreKeys.has(key)) continue;\n    const val1 = (node1 as any)[key];\n    const val2 = (node2 as any)[key];\n    if (val1 && !val2) return false;\n    if (Array.isArray(val1)) {\n      if (val1.length !== val2.length) return false;\n      for (let i = 0; i < val1.length; i++) {\n        if (!nodesMatch(val1[i], val2[i])) return false;\n      }\n    } else if (typeof val1 === 'object') {\n      if (!nodesMatch(val1, val2)) return false;\n    } else if (val1 !== val2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/** @hidden */\nexport interface NodeAndVarDefs {\n  node: ASTNode;\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>;\n}\n\n/** @hidden */\nexport interface FragmentPathMap {\n  [fragmentName: string]: ReadonlyArray<ReadonlyArray<string>>;\n}\n\n/** @hidden */\ninterface MutableFragmentPathMap {\n  [fragmentName: string]: Array<ReadonlyArray<string>>;\n}\n\n/** @hidden */\nexport class FragmentTracer {\n  private fragmentPathMap?: FragmentPathMap;\n  private doc: DocumentNode;\n\n  constructor(doc: DocumentNode) {\n    this.doc = doc;\n  }\n\n  public getPathsToFragment(fragmentName: string): ReadonlyArray<ReadonlyArray<string>> {\n    if (!this.fragmentPathMap) {\n      this.fragmentPathMap = this.buildFragmentPathMap();\n    }\n    return this.fragmentPathMap[fragmentName] || [];\n  }\n\n  // prepend the paths from the original document into this fragment to the inner fragment paths\n  public prependFragmentPaths(\n    fragmentName: string,\n    pathWithinFragment: ReadonlyArray<string>\n  ): ReadonlyArray<ReadonlyArray<string>> {\n    return this.getPathsToFragment(fragmentName).map(path => [...path, ...pathWithinFragment]);\n  }\n\n  private getFragmentDefs(): ReadonlyArray<FragmentDefinitionNode> {\n    return this.doc.definitions.filter(\n      ({ kind }) => kind === 'FragmentDefinition'\n    ) as FragmentDefinitionNode[];\n  }\n\n  private getFragmentPartialPathMap(startNode: ASTNode): MutableFragmentPathMap {\n    const partialPathMap: MutableFragmentPathMap = {};\n    const recursivelyBuildFragmentPaths = (node: ASTNode, curParents: ReadonlyArray<ASTNode>) => {\n      if (node.kind === 'FragmentSpread') {\n        pushToArrayAtKey(partialPathMap, node.name.value, extractPath(curParents));\n      }\n      const nextParents = [...curParents, node];\n      if ('selectionSet' in node && node.selectionSet) {\n        for (const selection of node.selectionSet.selections) {\n          recursivelyBuildFragmentPaths(selection, nextParents);\n        }\n      }\n    };\n    recursivelyBuildFragmentPaths(startNode, []);\n    return partialPathMap;\n  }\n\n  private mergeFragmentPaths(\n    fragmentName: string,\n    paths: Array<ReadonlyArray<string>>,\n    fragmentPartialPathsMap: { [fragmentName: string]: FragmentPathMap }\n  ) {\n    const mergedPaths: MutableFragmentPathMap = {};\n\n    const resursivelyBuildMergedPathsMap = (\n      curFragmentName: string,\n      curPaths: Array<ReadonlyArray<string>>,\n      seenFragments: ReadonlySet<string>\n    ) => {\n      // recursive fragments are invalid graphQL - just exit here. otherwise this will be an infinite loop\n      if (seenFragments.has(curFragmentName)) return;\n      const nextSeenFragments = new Set(seenFragments);\n      nextSeenFragments.add(curFragmentName);\n      const nextPartialPaths = fragmentPartialPathsMap[curFragmentName];\n      // if there are not other fragments nested inside of this fragment, we're done\n      if (!nextPartialPaths) return;\n\n      for (const [childFragmentName, childFragmentPaths] of Object.entries(nextPartialPaths)) {\n        for (const path of curPaths) {\n          const mergedChildPaths: Array<ReadonlyArray<string>> = [];\n          for (const childPath of childFragmentPaths) {\n            const mergedPath = [...path, ...childPath];\n            mergedChildPaths.push(mergedPath);\n            pushToArrayAtKey(mergedPaths, childFragmentName, mergedPath);\n          }\n          resursivelyBuildMergedPathsMap(childFragmentName, mergedChildPaths, nextSeenFragments);\n        }\n      }\n    };\n\n    resursivelyBuildMergedPathsMap(fragmentName, paths, new Set());\n    return mergedPaths;\n  }\n\n  private buildFragmentPathMap(): FragmentPathMap {\n    const mainOperation = this.doc.definitions.find(node => node.kind === 'OperationDefinition');\n    if (!mainOperation) return {};\n\n    // partial paths are the paths inside of each fragmnt to other fragments\n    const fragmentPartialPathsMap: { [fragmentName: string]: FragmentPathMap } = {};\n    for (const fragmentDef of this.getFragmentDefs()) {\n      fragmentPartialPathsMap[fragmentDef.name.value] = this.getFragmentPartialPathMap(fragmentDef);\n    }\n\n    // start with the direct paths to fragments inside of the main operation\n    const simpleFragmentPathMap: MutableFragmentPathMap = this.getFragmentPartialPathMap(\n      mainOperation\n    );\n    const fragmentPathMap: MutableFragmentPathMap = { ...simpleFragmentPathMap };\n    // next, we'll recursively trace the partials into their subpartials to fill out all possible paths to each fragment\n    for (const [fragmentName, simplePaths] of Object.entries(simpleFragmentPathMap)) {\n      const mergedFragmentPathsMap = this.mergeFragmentPaths(\n        fragmentName,\n        simplePaths,\n        fragmentPartialPathsMap\n      );\n      for (const [mergedFragmentName, mergedFragmentPaths] of Object.entries(\n        mergedFragmentPathsMap\n      )) {\n        fragmentPathMap[mergedFragmentName] = [\n          ...(fragmentPathMap[mergedFragmentName] || []),\n          ...mergedFragmentPaths\n        ];\n      }\n    }\n\n    return fragmentPathMap;\n  }\n}\n\n/**\n * Walk the document add rewrite nodes along the way\n * @param doc\n * @param callback Called on each node, and returns a new rewritten node\n * @hidden\n */\nexport const rewriteDoc = (\n  doc: DocumentNode,\n  callback: (nodeAndVars: NodeAndVarDefs, parents: ReadonlyArray<ASTNode>) => NodeAndVarDefs\n): DocumentNode => {\n  let variableDefinitions = extractVariableDefinitions(doc);\n  const walkRecursive = (\n    curNodeAndVars: NodeAndVarDefs,\n    curParents: ReadonlyArray<ASTNode>\n  ): ASTNode => {\n    const nextNodeAndVars = callback(curNodeAndVars, curParents);\n    variableDefinitions = nextNodeAndVars.variableDefinitions;\n    const node = nextNodeAndVars.node;\n    const nextParents = [...curParents, node];\n    for (const key of Object.keys(node)) {\n      if (key === 'loc') continue;\n      const val = (node as any)[key];\n      if (Array.isArray(val)) {\n        (node as any)[key] = val.map(elm => {\n          if (typeof elm === 'object') {\n            const next: NodeAndVarDefs = {\n              variableDefinitions,\n              node: elm\n            };\n            return walkRecursive(next, nextParents);\n          }\n          return elm;\n        });\n      } else if (typeof val === 'object') {\n        const next: NodeAndVarDefs = {\n          variableDefinitions,\n          node: val\n        };\n        (node as any)[key] = walkRecursive(next, nextParents);\n      }\n    }\n    return node;\n  };\n\n  const root: NodeAndVarDefs = {\n    variableDefinitions,\n    node: doc\n  };\n  const rewrittenDoc = walkRecursive(root, []) as DocumentNode;\n  return replaceVariableDefinitions(rewrittenDoc, variableDefinitions);\n};\n\n/** @hidden */\nexport const extractVariableDefinitions = (\n  doc: DocumentNode\n): ReadonlyArray<VariableDefinitionNode> => {\n  for (const def of doc.definitions) {\n    if (def.kind === 'OperationDefinition') {\n      return def.variableDefinitions || [];\n    }\n  }\n  return [];\n};\n\n/** @hidden */\nexport const replaceVariableDefinitions = (\n  doc: DocumentNode,\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>\n): DocumentNode => {\n  const definitions = doc.definitions.map(def => {\n    if (def.kind === 'OperationDefinition') {\n      return { ...def, variableDefinitions };\n    }\n    return def;\n  });\n  return { ...doc, definitions };\n};\n\n/**\n * return the path that will be returned in the response from from the chain of parents\n */\n/** @hidden */\nexport const extractPath = (parents: ReadonlyArray<ASTNode>): ReadonlyArray<string> => {\n  const path: string[] = [];\n  parents.forEach(parent => {\n    if (parent.kind === 'Field') {\n      path.push(parent.name.value);\n    }\n  });\n  return path;\n};\n\n/** @hidden */\ninterface ResultObj {\n  [key: string]: any;\n}\n\n/** @hidden */\nexport const rewriteResultsAtPath = (\n  results: ResultObj,\n  path: ReadonlyArray<string>,\n  callback: (parentResult: any, key: string, position?: number) => any\n): ResultObj => {\n  if (path.length === 0) return results;\n\n  const curPathElm = path[0];\n  const newResults = { ...results };\n  const curResults = results[curPathElm];\n\n  if (path.length === 1) {\n    if (Array.isArray(curResults)) {\n      return curResults.reduce(\n        (reducedResults, _, index) => callback(reducedResults, curPathElm, index),\n        results\n      );\n    }\n\n    return callback(results, curPathElm);\n  }\n\n  const remainingPath = path.slice(1);\n  // if the path stops here, just return results without any rewriting\n  if (curResults === undefined || curResults === null) return results;\n\n  if (Array.isArray(curResults)) {\n    newResults[curPathElm] = curResults.map(result =>\n      rewriteResultsAtPath(result, remainingPath, callback)\n    );\n  } else {\n    newResults[curPathElm] = rewriteResultsAtPath(curResults, remainingPath, callback);\n  }\n\n  return newResults;\n};\n","import { FragmentDefinitionNode, parse, print } from 'graphql';\nimport { extractPath, FragmentTracer, rewriteDoc, rewriteResultsAtPath } from './ast';\nimport Rewriter, { Variables } from './rewriters/Rewriter';\n\ninterface RewriterMatch {\n  rewriter: Rewriter;\n  paths: ReadonlyArray<ReadonlyArray<string>>;\n}\n\n/**\n * Create a new instance of this class for each request that needs to be processed\n * This class handles rewriting the query and the reponse according to the rewriters passed in\n */\nexport default class RewriteHandler {\n  public matches: RewriterMatch[] = [];\n\n  private rewriters: Rewriter[];\n  private hasProcessedRequest: boolean = false;\n  private hasProcessedResponse: boolean = false;\n\n  constructor(rewriters: Rewriter[]) {\n    this.rewriters = rewriters;\n  }\n\n  /**\n   * Call this on a graphQL request in middleware before passing on to the real graphql processor\n   * @param query The graphQL query\n   * @param variables The variables map for the graphQL query\n   */\n  public rewriteRequest(query: string, variables?: Variables) {\n    if (this.hasProcessedRequest) throw new Error('This handler has already rewritten a request');\n    this.hasProcessedRequest = true;\n    const doc = parse(query);\n    const fragmentTracer = new FragmentTracer(doc);\n    let rewrittenVariables = variables;\n    const rewrittenDoc = rewriteDoc(doc, (nodeAndVars, parents) => {\n      let rewrittenNodeAndVars = nodeAndVars;\n      this.rewriters.forEach(rewriter => {\n        const isMatch = rewriter.matches(nodeAndVars, parents);\n        if (isMatch) {\n          rewrittenVariables = rewriter.rewriteVariables(rewrittenNodeAndVars, rewrittenVariables);\n          rewrittenNodeAndVars = rewriter.rewriteQuery(rewrittenNodeAndVars, rewrittenVariables);\n          const simplePath = extractPath([...parents, rewrittenNodeAndVars.node]);\n          let paths: ReadonlyArray<ReadonlyArray<string>> = [simplePath];\n          const fragmentDef = parents.find(({ kind }) => kind === 'FragmentDefinition') as\n            | FragmentDefinitionNode\n            | undefined;\n          if (fragmentDef) {\n            paths = fragmentTracer.prependFragmentPaths(fragmentDef.name.value, simplePath);\n          }\n          this.matches.push({\n            rewriter,\n            paths\n          });\n        }\n        return isMatch;\n      });\n      return rewrittenNodeAndVars;\n    });\n\n    return { query: print(rewrittenDoc), variables: rewrittenVariables };\n  }\n\n  /**\n   * Call this on the response returned from graphQL before passing it back to the client\n   * This will change the output to match what the original query requires\n   * @param response The graphQL response object\n   */\n  public rewriteResponse(response: any) {\n    if (this.hasProcessedResponse) throw new Error('This handler has already returned a response');\n    this.hasProcessedResponse = true;\n    let rewrittenResponse = response;\n    this.matches.reverse().forEach(({ rewriter, paths }) => {\n      paths.forEach(path => {\n        rewrittenResponse = rewriteResultsAtPath(\n          rewrittenResponse,\n          path,\n          (parentResponse, key, index) => rewriter.rewriteResponse(parentResponse, key, index)\n        );\n      });\n    });\n    return rewrittenResponse;\n  }\n}\n","import { ASTNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport matchCondition from '../matchConditions/matchCondition';\n\nexport type Variables = { [key: string]: any } | undefined;\nexport type RootType = 'query' | 'mutation' | 'fragment';\n\nexport interface RewriterOpts {\n  fieldName?: string;\n  rootTypes?: RootType[];\n  matchConditions?: matchCondition[];\n}\n\n/**\n * Abstract base Rewriter class\n * Extend this class and overwrite its methods to create a new rewriter\n */\nabstract class Rewriter {\n  protected rootTypes: RootType[] = ['query', 'mutation', 'fragment'];\n  protected fieldName?: string;\n  protected matchConditions?: matchCondition[];\n\n  constructor({ fieldName, rootTypes, matchConditions }: RewriterOpts) {\n    this.fieldName = fieldName;\n    this.matchConditions = matchConditions;\n    if (!this.fieldName && !this.matchConditions) {\n      throw new Error(\n        'Neither a fieldName or matchConditions were provided. Please choose to pass either one in order to be able to detect which fields to rewrite.'\n      );\n    }\n    if (rootTypes) this.rootTypes = rootTypes;\n  }\n\n  public matches(nodeAndVarDefs: NodeAndVarDefs, parents: ReadonlyArray<ASTNode>): boolean {\n    const { node } = nodeAndVarDefs;\n\n    // If no fieldName is provided, check for defined matchConditions.\n    // This avoids having to define one rewriter for many fields individually.\n    // Alternatively, regex matching for fieldName could be implemented.\n    if (\n      node.kind !== 'Field' ||\n      (this.fieldName ? node.name.value !== this.fieldName : !this.matchConditions)\n    ) {\n      return false;\n    }\n    const root = parents[0];\n    if (\n      root.kind === 'OperationDefinition' &&\n      this.rootTypes.indexOf(root.operation as RootType) === -1\n    ) {\n      return false;\n    }\n    if (root.kind === 'FragmentDefinition' && this.rootTypes.indexOf('fragment') === -1) {\n      return false;\n    }\n    if (\n      this.matchConditions &&\n      !this.matchConditions.find(condition => condition(nodeAndVarDefs, parents))\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs, variables: Variables): NodeAndVarDefs {\n    return nodeAndVarDefs;\n  }\n\n  public rewriteVariables(nodeAndVarDefs: NodeAndVarDefs, variables: Variables): Variables {\n    return variables;\n  }\n\n  /*\n   * Receives the parent object of the matched field with the key of the matched field.\n   * For arrays, the index of the element is also present.\n   */\n  public rewriteResponse(response: any, key: string, index?: number): any {\n    return response;\n  }\n\n  /*\n   * Helper that extracts the element from the response if possible otherwise returns null.\n   */\n  protected extractReponseElement(response: any, key: string, index?: number): any {\n    // Verify the response format\n    let element = null;\n    if (response === null || typeof response !== 'object') return element;\n\n    // Extract the key\n    element = response[key] || null;\n\n    // Extract the position\n    if (Array.isArray(element)) {\n      element = element[index!] || null;\n    }\n\n    return element;\n  }\n\n  /*\n   * Helper that rewrite the element from the response if possible and returns the response.\n   */\n  protected rewriteResponseElement(\n    response: any,\n    newElement: any,\n    key: string,\n    index?: number\n  ): any {\n    // Verify the response format\n    if (response === null || typeof response !== 'object') return response;\n\n    // Extract the key\n    const element = response[key];\n\n    // Extract the position\n    // NOTE: We might eventually want to create an array if one is not present at the key\n    // and we receive an index in input\n    if (Array.isArray(element)) {\n      element[index!] = newElement;\n    } else {\n      response[key] = newElement;\n    }\n\n    return response;\n  }\n}\n\nexport default Rewriter;\n","import { ASTNode, FieldNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface IFieldArgNameRewriterOpts extends RewriterOpts {\n  oldArgName: string;\n  newArgName: string;\n}\n\n/**\n * Rewriter which replaces the name of a single argument of a field\n * ex: change from thingID: ID! to thingId: ID!\n */\nclass FieldArgNameRewriter extends Rewriter {\n  protected oldArgName: string;\n  protected newArgName: string;\n\n  constructor(options: IFieldArgNameRewriterOpts) {\n    super(options);\n    this.oldArgName = options.oldArgName;\n    this.newArgName = options.newArgName;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // is this a field with the correct arguments?\n    if (!node.arguments) return false;\n    // is there an argument with the correct name?\n    return !!node.arguments.find(arg => arg.name.value === this.oldArgName);\n  }\n\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\n    const newArguments = ((node as FieldNode).arguments || []).map(argument => {\n      if (argument.name.value === this.oldArgName) {\n        return { ...argument, name: { ...argument.name, value: this.newArgName } };\n      }\n      return argument;\n    });\n    return { variableDefinitions, node: { ...node, arguments: newArguments } } as NodeAndVarDefs;\n  }\n}\n\nexport default FieldArgNameRewriter;\n","import { ArgumentNode, ASTNode, FieldNode, ObjectFieldNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface FieldArgsToInputTypeRewriterOpts extends RewriterOpts {\n  argNames: string[];\n  inputArgName?: string;\n}\n\n/**\n * Rewriter which replaces the args to a field with an input type\n * ex: change from field(id: $id, arg2: $arg2) to field(input: { id: $id, arg2: $arg2 })\n */\nclass FieldArgsToInputTypeRewriter extends Rewriter {\n  protected argNames: string[];\n  protected inputArgName: string = 'input';\n\n  constructor(options: FieldArgsToInputTypeRewriterOpts) {\n    super(options);\n    this.fieldName = options.fieldName;\n    this.argNames = options.argNames;\n    if (options.inputArgName) this.inputArgName = options.inputArgName;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // is this a field with the correct fieldName and arguments?\n    if (node.name.value !== this.fieldName || !node.arguments) return false;\n    // if there's already an input type in this field, skip it\n    if (node.arguments.find(arg => arg.name.value === this.inputArgName)) {\n      return false;\n    }\n    // is there an argument with the correct name?\n    return !!node.arguments.find(arg => this.argNames.indexOf(arg.name.value) >= 0);\n  }\n\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\n    const argsToNest = ((node as FieldNode).arguments || []).filter(\n      argument => this.argNames.indexOf(argument.name.value) >= 0\n    );\n    const newArguments = ((node as FieldNode).arguments || []).filter(\n      argument => this.argNames.indexOf(argument.name.value) === -1\n    );\n    const inputArgument: ArgumentNode = {\n      kind: 'Argument',\n      name: { kind: 'Name', value: this.inputArgName },\n      value: {\n        kind: 'ObjectValue',\n        fields: argsToNest.map(\n          (arg): ObjectFieldNode => ({\n            kind: 'ObjectField',\n            name: arg.name,\n            value: arg.value\n          })\n        )\n      }\n    };\n    newArguments.push(inputArgument);\n    return { variableDefinitions, node: { ...node, arguments: newArguments } } as NodeAndVarDefs;\n  }\n}\n\nexport default FieldArgsToInputTypeRewriter;\n","import {\n  ArgumentNode,\n  ASTNode,\n  FieldNode,\n  isValueNode,\n  Kind,\n  ObjectFieldNode,\n  parseType,\n  TypeNode,\n  ValueNode,\n  VariableNode\n} from 'graphql';\nimport Maybe from 'graphql/tsutils/Maybe';\nimport { NodeAndVarDefs, nodesMatch } from '../ast';\nimport { identifyFunc } from '../utils';\nimport Rewriter, { RewriterOpts, Variables } from './Rewriter';\n\ninterface FieldArgTypeRewriterOpts extends RewriterOpts {\n  root?: string;\n  argName: string;\n  oldType: string;\n  newType: string;\n  coerceVariable?: (variable: any, context: { variables: Variables; args: ArgumentNode[] }) => any;\n  /**\n   * EXPERIMENTAL:\n   *  This allows to coerce value of argument when their value is not stored in a variable\n   *  but comes in the query node itself.\n   *  NOTE: At the moment, the user has to return the ast value node herself.\n   */\n  coerceArgumentValue?: (\n    variable: any,\n    context: { variables: Variables; args: ArgumentNode[] }\n  ) => Maybe<ValueNode>;\n}\n\n/**\n * Rewriter which replaces the type of a single argument of a field\n * ex: change from id: String! to id: ID!\n */\nclass FieldArgTypeRewriter extends Rewriter {\n  protected argName: string;\n  protected root?: string;\n  protected oldTypeNode: TypeNode;\n  protected newTypeNode: TypeNode;\n  // Passes context with rest of arguments and variables.\n  // Quite useful for variable coercion that depends on other arguments/variables\n  // (e.g., [offset, limit] to [pageSize, pageNumber] coercion)\n  protected coerceVariable: (\n    variable: any,\n    context: { variables: Variables; args: ArgumentNode[] }\n  ) => any;\n  // (Experimental): Used to coerce arguments whose value\n  // does not come in a variable.\n  protected coerceArgumentValue: (\n    variable: any,\n    context: { variables: Variables; args: ArgumentNode[] }\n  ) => Maybe<ValueNode>;\n\n  constructor(options: FieldArgTypeRewriterOpts) {\n    super(options);\n    this.root = options.root;\n    this.argName = options.argName;\n    this.oldTypeNode = parseType(options.oldType);\n    this.newTypeNode = parseType(options.newType);\n    this.coerceVariable = options.coerceVariable || identifyFunc;\n    this.coerceArgumentValue = options.coerceArgumentValue || identifyFunc;\n  }\n\n  private getMatchingArgument(node: FieldNode) {\n    if (this.root) {\n      const rootNode = (node.arguments || []).find(arg => arg.name.value === this.root);\n      if (!rootNode) return undefined;\n      if (rootNode.value.kind === 'ObjectValue') {\n        return rootNode.value.fields.find(field => field.name.value === this.argName);\n      }\n    } else {\n      return (node.arguments || []).find(arg => arg.name.value === this.argName);\n    }\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    const { variableDefinitions } = nodeAndVars;\n    // is this a field with the correct fieldName and arguments?\n    if (node.kind !== 'Field') return false;\n\n    // does this field contain arguments?\n    if (!node.arguments) return false;\n\n    const matchingArgument = this.getMatchingArgument(node);\n\n    if (!matchingArgument) return false;\n\n    // argument value is stored in a variable\n    if (matchingArgument.value.kind === 'Variable') {\n      const varRef = matchingArgument.value.name.value;\n      // does the referenced variable have the correct type?\n      for (const varDefinition of variableDefinitions) {\n        if (varDefinition.variable.name.value === varRef) {\n          return nodesMatch(this.oldTypeNode, varDefinition.type);\n        }\n      }\n    }\n    // argument value comes in query doc.\n    else {\n      const argValueNode = matchingArgument.value;\n      return isValueNode(argValueNode);\n      // Would be ideal to do a nodesMatch in here, however argument value nodes\n      // have different format for their values than when passed as variables.\n      // For instance, are parsed with Kinds as \"graphql.Kind\" (e.g., INT=\"IntValue\") and not \"graphql.TokenKinds\" (e.g., INT=\"Int\")\n      // So they might not match correctly. Also they dont contain additional parsed syntax\n      // as the non-optional symbol \"!\". So just return true if the argument.value is a ValueNode.\n      //\n      // return nodesMatch(this.oldTypeNode, parseType(argRef.kind));\n    }\n\n    return false;\n  }\n\n  public rewriteQuery(\n    { node: astNode, variableDefinitions }: NodeAndVarDefs,\n    variables: Variables\n  ) {\n    const node = astNode as FieldNode;\n    const varRefName = this.extractMatchingVarRefName(node);\n    // If argument value is stored in a variable\n    if (varRefName) {\n      const newVarDefs = variableDefinitions.map(varDef => {\n        if (varDef.variable.name.value !== varRefName) return varDef;\n        return { ...varDef, type: this.newTypeNode };\n      });\n      return { node, variableDefinitions: newVarDefs };\n    }\n    // If argument value is not stored in a variable but in the query node.\n    const matchingArgument = this.getMatchingArgument(node);\n    if (node.arguments && matchingArgument) {\n      const args = [...node.arguments];\n      const newValue = this.coerceArgumentValue(matchingArgument.value, { variables, args });\n      /**\n       * TODO: If somewhow we can get the schema here, we could make the coerceArgumentValue\n       * even easier, as we would be able to construct the ast node for the argument value.\n       * as of now, the user has to take care of correctly constructing the argument value ast node herself.\n       *\n       * const schema = makeExecutableSchema({typeDefs})\n       * const myCustomType = schema.getType(\"MY_CUSTOM_TYPE_NAME\")\n       * const newArgValue = astFromValue(newValue, myCustomType)\n       * Object.assign(matchingArgument, { value: newArgValue })\n       */\n      if (newValue) Object.assign(matchingArgument, { value: newValue });\n    }\n    return { node, variableDefinitions };\n  }\n\n  public rewriteVariables({ node: astNode }: NodeAndVarDefs, variables: Variables) {\n    const node = astNode as FieldNode;\n    if (!variables) return variables;\n    const varRefName = this.extractMatchingVarRefName(node);\n    const args = [...(node.arguments ? node.arguments : [])];\n    return {\n      ...variables,\n      ...(varRefName\n        ? { [varRefName]: this.coerceVariable(variables[varRefName], { variables, args }) }\n        : {})\n    };\n  }\n\n  private extractMatchingVarRefName(node: FieldNode) {\n    const matchingArgument = this.getMatchingArgument(node)!;\n    const variableNode = matchingArgument.value as VariableNode;\n    return variableNode.kind === Kind.VARIABLE && variableNode.name.value;\n  }\n}\n\nexport default FieldArgTypeRewriter;\n","import { ASTNode, FieldNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface NestFieldOutputsRewriterOpts extends RewriterOpts {\n  newOutputName: string;\n  outputsToNest: string[];\n}\n\n/**\n * Rewriter which nests output fields inside of a new output object\n * ex: change from `field { output1, output2 }` to `field { nestedOutputs { output1, output 2 } }`\n */\nclass NestFieldOutputsRewriter extends Rewriter {\n  protected newOutputName: string;\n  protected outputsToNest: string[];\n\n  constructor(options: NestFieldOutputsRewriterOpts) {\n    super(options);\n    this.newOutputName = options.newOutputName;\n    this.outputsToNest = options.outputsToNest;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // is this a field with the correct selections?\n    if (!node.selectionSet) return false;\n    // if `newOutputName` already exists as an output, skip it\n    if (\n      node.selectionSet.selections.find(\n        output => output.kind === 'Field' && output.name.value === this.newOutputName\n      )\n    ) {\n      return false;\n    }\n    // is there an output with a matching name?\n    return !!node.selectionSet.selections.find(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) >= 0\n    );\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs) {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    if (!node.selectionSet) return nodeAndVarDefs;\n    const outputsToNest = (node.selectionSet.selections || []).filter(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) >= 0\n    );\n    const newOutputs = (node.selectionSet.selections || []).filter(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) === -1\n    );\n    const nestedOutput: FieldNode = {\n      kind: 'Field',\n      name: { kind: 'Name', value: this.newOutputName },\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: outputsToNest\n      }\n    };\n    newOutputs.push(nestedOutput);\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet: { ...node.selectionSet, selections: newOutputs } }\n    } as NodeAndVarDefs;\n  }\n\n  public rewriteResponse(response: any, key: string, index?: number) {\n    // Extract the element we are working on\n    const element = super.extractReponseElement(response, key, index);\n    if (element === null || typeof element !== 'object') return response;\n\n    // Undo the nesting in the response so it matches the original query\n    if (element[this.newOutputName] && typeof element[this.newOutputName] === 'object') {\n      const newElement = { ...element, ...element[this.newOutputName] };\n      delete newElement[this.newOutputName];\n\n      return super.rewriteResponseElement(response, newElement, key, index);\n    }\n\n    return response;\n  }\n}\n\nexport default NestFieldOutputsRewriter;\n","import { ASTNode, FieldNode, SelectionSetNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface ScalarFieldToObjectFieldRewriterOpts extends RewriterOpts {\n  objectFieldName: string;\n}\n\n/**\n * Rewriter which nests a scalar field inside of a new output object\n * ex: change from `field { subField }` to `field { subField { objectfield } }`\n */\nclass ScalarFieldToObjectFieldRewriter extends Rewriter {\n  protected objectFieldName: string;\n\n  constructor(options: ScalarFieldToObjectFieldRewriterOpts) {\n    super(options);\n    this.objectFieldName = options.objectFieldName;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]): boolean {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // make sure there's no subselections on this field\n    if (node.selectionSet) return false;\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs) {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    // if there's a subselection already, just return\n    if (node.selectionSet) return nodeAndVarDefs;\n\n    const selectionSet: SelectionSetNode = {\n      kind: 'SelectionSet',\n      selections: [\n        {\n          kind: 'Field',\n          name: { kind: 'Name', value: this.objectFieldName }\n        }\n      ]\n    };\n\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet }\n    } as NodeAndVarDefs;\n  }\n\n  public rewriteResponse(response: any, key: string, index?: number) {\n    // Extract the element we are working on\n    const element = super.extractReponseElement(response, key, index);\n    if (element === null) return response;\n\n    // Undo the nesting in the response so it matches the original query\n    const newElement = element[this.objectFieldName];\n    return super.rewriteResponseElement(response, newElement, key, index);\n  }\n}\n\nexport default ScalarFieldToObjectFieldRewriter;\n","import { ASTNode, FieldNode, SelectionSetNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface ObjectField {\n  name: string;\n  subfields?: ObjectField[];\n}\n\ninterface JsonToTypedObjectRewriterOpts extends RewriterOpts {\n  objectFields: ObjectField[];\n}\n\nexport default class JsonToTypedObjectRewriter extends Rewriter {\n  protected objectFields: ObjectField[];\n\n  constructor({ fieldName, objectFields }: JsonToTypedObjectRewriterOpts) {\n    super({ fieldName });\n    this.objectFields = objectFields;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]): boolean {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // make sure there's no subselections on this field\n    if (node.selectionSet) return false;\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs): NodeAndVarDefs {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    // if there's a subselection already, just return\n    if (node.selectionSet) return nodeAndVarDefs;\n\n    const selectionSet = this.generateSelectionSet(this.objectFields);\n\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet }\n    } as NodeAndVarDefs;\n  }\n\n  private generateSelectionSet(fields: ObjectField[]): SelectionSetNode {\n    return {\n      kind: 'SelectionSet',\n      selections: fields.map(({ name, subfields }) => ({\n        kind: 'Field',\n        name: { kind: 'Name', value: name },\n        ...(subfields && {\n          selectionSet: this.generateSelectionSet(subfields)\n        })\n      }))\n    } as SelectionSetNode;\n  }\n}\n","import { FragmentDefinitionNode } from 'graphql';\nimport { extractPath } from '../ast';\nimport matchCondition from './matchCondition';\nexport interface FragmentMatchConditionOpts {\n  fragmentNames?: string[];\n  fragmentTypes?: string[];\n  pathRegexes?: RegExp[];\n}\n\nconst fragmentMatchCondition = ({\n  fragmentNames,\n  fragmentTypes,\n  pathRegexes\n}: FragmentMatchConditionOpts = {}): matchCondition => {\n  return ({ node }, parents) => {\n    const fragmentDef = parents.find(({ kind }) => kind === 'FragmentDefinition') as\n      | FragmentDefinitionNode\n      | undefined;\n    if (!fragmentDef) return false;\n\n    if (fragmentNames && !fragmentNames.includes(fragmentDef.name.value)) {\n      return false;\n    }\n\n    if (fragmentTypes && !fragmentTypes.includes(fragmentDef.typeCondition.name.value)) {\n      return false;\n    }\n\n    if (pathRegexes) {\n      const pathStr = extractPath([...parents, node]).join('.');\n      if (!pathRegexes.find(pathRegex => pathRegex.test(pathStr))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n};\n\nexport default fragmentMatchCondition;\n","import { OperationDefinitionNode } from 'graphql';\nimport { extractPath } from '../ast';\nimport matchCondition from './matchCondition';\n\n/** @hidden */\nexport interface OperationMatchConditionOpts {\n  operationNames?: string[];\n  operationTypes?: string[];\n  pathRegexes?: RegExp[];\n}\n\n/** @hidden */\nexport default ({\n  operationNames,\n  operationTypes,\n  pathRegexes\n}: OperationMatchConditionOpts = {}): matchCondition => {\n  return ({ node }, parents) => {\n    const operationDef = parents.find(({ kind }) => kind === 'OperationDefinition') as\n      | OperationDefinitionNode\n      | undefined;\n\n    if (!operationDef) return false;\n\n    if (operationNames) {\n      if (!operationDef.name || !operationNames.includes(operationDef.name.value)) {\n        return false;\n      }\n    }\n\n    if (operationTypes && !operationTypes.includes(operationDef.operation)) {\n      return false;\n    }\n\n    if (pathRegexes) {\n      const pathStr = extractPath([...parents, node]).join('.');\n      if (!pathRegexes.find(pathRegex => pathRegex.test(pathStr))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n};\n","import matchCondition from './matchCondition';\nimport operationMatchCondition from './operationMatchCondition';\nexport interface QueryMatchConditionOpts {\n  queryNames?: string[];\n  pathRegexes?: RegExp[];\n}\n\nconst queryMatchCondition = ({\n  queryNames,\n  pathRegexes\n}: QueryMatchConditionOpts = {}): matchCondition => {\n  return operationMatchCondition({\n    pathRegexes,\n    operationNames: queryNames,\n    operationTypes: ['query']\n  });\n};\n\nexport default queryMatchCondition;\n","import matchCondition from './matchCondition';\nimport operationMatchCondition from './operationMatchCondition';\nexport interface MutationMatchConditionOpts {\n  mutationNames?: string[];\n  pathRegexes?: RegExp[];\n}\n\nconst mutationMatchCondition = ({\n  mutationNames,\n  pathRegexes\n}: MutationMatchConditionOpts = {}): matchCondition => {\n  return operationMatchCondition({\n    pathRegexes,\n    operationNames: mutationNames,\n    operationTypes: ['mutation']\n  });\n};\n\nexport default mutationMatchCondition;\n"],"names":["tslib_1.__extends"],"mappings":"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"}