{"version":3,"file":"index.umd.js","sources":["../src/utils.ts","../src/ast.ts","../src/RewriteHandler.ts","../src/rewriters/Rewriter.ts","../src/rewriters/FieldArgNameRewriter.ts","../src/rewriters/FieldArgsToInputTypeRewriter.ts","../src/rewriters/FieldArgTypeRewriter.ts","../src/rewriters/NestFieldOutputsRewriter.ts","../src/rewriters/ScalarFieldToObjectFieldRewriter.ts","../src/rewriters/JsonToTypedObjectRewriter.ts","../src/matchConditions/fragmentMatchCondition.ts","../src/matchConditions/operationMatchCondition.ts","../src/matchConditions/queryMatchCondition.ts","../src/matchConditions/mutationMatchCondition.ts"],"sourcesContent":["/** @hidden */\nexport const identifyFunc = <T>(val: T) => val;\n\n/** @hidden */\nexport const pushToArrayAtKey = <T>(mapping: { [key: string]: T[] }, key: string, val: T): void => {\n  if (!mapping[key]) mapping[key] = [];\n  mapping[key].push(val);\n};\n","import { ASTNode, DocumentNode, FragmentDefinitionNode, VariableDefinitionNode } from 'graphql';\nimport { pushToArrayAtKey } from './utils';\n\nconst ignoreKeys = new Set(['loc']);\n\n/** @hidden */\nexport const nodesMatch = (node1: ASTNode, node2: ASTNode): boolean => {\n  for (const key of Object.keys(node1)) {\n    if (ignoreKeys.has(key)) continue;\n    const val1 = (node1 as any)[key];\n    const val2 = (node2 as any)[key];\n    if (val1 && !val2) return false;\n    if (Array.isArray(val1)) {\n      if (val1.length !== val2.length) return false;\n      for (let i = 0; i < val1.length; i++) {\n        if (!nodesMatch(val1[i], val2[i])) return false;\n      }\n    } else if (typeof val1 === 'object') {\n      if (!nodesMatch(val1, val2)) return false;\n    } else if (val1 !== val2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/** @hidden */\nexport interface NodeAndVarDefs {\n  node: ASTNode;\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>;\n}\n\n/** @hidden */\nexport interface FragmentPathMap {\n  [fragmentName: string]: ReadonlyArray<ReadonlyArray<string>>;\n}\n\n/** @hidden */\ninterface MutableFragmentPathMap {\n  [fragmentName: string]: Array<ReadonlyArray<string>>;\n}\n\n/** @hidden */\nexport class FragmentTracer {\n  private fragmentPathMap?: FragmentPathMap;\n  private doc: DocumentNode;\n\n  constructor(doc: DocumentNode) {\n    this.doc = doc;\n  }\n\n  public getPathsToFragment(fragmentName: string): ReadonlyArray<ReadonlyArray<string>> {\n    if (!this.fragmentPathMap) {\n      this.fragmentPathMap = this.buildFragmentPathMap();\n    }\n    return this.fragmentPathMap[fragmentName] || [];\n  }\n\n  // prepend the paths from the original document into this fragment to the inner fragment paths\n  public prependFragmentPaths(\n    fragmentName: string,\n    pathWithinFragment: ReadonlyArray<string>\n  ): ReadonlyArray<ReadonlyArray<string>> {\n    return this.getPathsToFragment(fragmentName).map(path => [...path, ...pathWithinFragment]);\n  }\n\n  private getFragmentDefs(): ReadonlyArray<FragmentDefinitionNode> {\n    return this.doc.definitions.filter(\n      ({ kind }) => kind === 'FragmentDefinition'\n    ) as FragmentDefinitionNode[];\n  }\n\n  private getFragmentPartialPathMap(startNode: ASTNode): MutableFragmentPathMap {\n    const partialPathMap: MutableFragmentPathMap = {};\n    const recursivelyBuildFragmentPaths = (node: ASTNode, curParents: ReadonlyArray<ASTNode>) => {\n      if (node.kind === 'FragmentSpread') {\n        pushToArrayAtKey(partialPathMap, node.name.value, extractPath(curParents));\n      }\n      const nextParents = [...curParents, node];\n      if ('selectionSet' in node && node.selectionSet) {\n        for (const selection of node.selectionSet.selections) {\n          recursivelyBuildFragmentPaths(selection, nextParents);\n        }\n      }\n    };\n    recursivelyBuildFragmentPaths(startNode, []);\n    return partialPathMap;\n  }\n\n  private mergeFragmentPaths(\n    fragmentName: string,\n    paths: Array<ReadonlyArray<string>>,\n    fragmentPartialPathsMap: { [fragmentName: string]: FragmentPathMap }\n  ) {\n    const mergedPaths: MutableFragmentPathMap = {};\n\n    const resursivelyBuildMergedPathsMap = (\n      curFragmentName: string,\n      curPaths: Array<ReadonlyArray<string>>,\n      seenFragments: ReadonlySet<string>\n    ) => {\n      // recursive fragments are invalid graphQL - just exit here. otherwise this will be an infinite loop\n      if (seenFragments.has(curFragmentName)) return;\n      const nextSeenFragments = new Set(seenFragments);\n      nextSeenFragments.add(curFragmentName);\n      const nextPartialPaths = fragmentPartialPathsMap[curFragmentName];\n      // if there are not other fragments nested inside of this fragment, we're done\n      if (!nextPartialPaths) return;\n\n      for (const [childFragmentName, childFragmentPaths] of Object.entries(nextPartialPaths)) {\n        for (const path of curPaths) {\n          const mergedChildPaths: Array<ReadonlyArray<string>> = [];\n          for (const childPath of childFragmentPaths) {\n            const mergedPath = [...path, ...childPath];\n            mergedChildPaths.push(mergedPath);\n            pushToArrayAtKey(mergedPaths, childFragmentName, mergedPath);\n          }\n          resursivelyBuildMergedPathsMap(childFragmentName, mergedChildPaths, nextSeenFragments);\n        }\n      }\n    };\n\n    resursivelyBuildMergedPathsMap(fragmentName, paths, new Set());\n    return mergedPaths;\n  }\n\n  private buildFragmentPathMap(): FragmentPathMap {\n    const mainOperation = this.doc.definitions.find(node => node.kind === 'OperationDefinition');\n    if (!mainOperation) return {};\n\n    // partial paths are the paths inside of each fragmnt to other fragments\n    const fragmentPartialPathsMap: { [fragmentName: string]: FragmentPathMap } = {};\n    for (const fragmentDef of this.getFragmentDefs()) {\n      fragmentPartialPathsMap[fragmentDef.name.value] = this.getFragmentPartialPathMap(fragmentDef);\n    }\n\n    // start with the direct paths to fragments inside of the main operation\n    const simpleFragmentPathMap: MutableFragmentPathMap = this.getFragmentPartialPathMap(\n      mainOperation\n    );\n    const fragmentPathMap: MutableFragmentPathMap = { ...simpleFragmentPathMap };\n    // next, we'll recursively trace the partials into their subpartials to fill out all possible paths to each fragment\n    for (const [fragmentName, simplePaths] of Object.entries(simpleFragmentPathMap)) {\n      const mergedFragmentPathsMap = this.mergeFragmentPaths(\n        fragmentName,\n        simplePaths,\n        fragmentPartialPathsMap\n      );\n      for (const [mergedFragmentName, mergedFragmentPaths] of Object.entries(\n        mergedFragmentPathsMap\n      )) {\n        fragmentPathMap[mergedFragmentName] = [\n          ...(fragmentPathMap[mergedFragmentName] || []),\n          ...mergedFragmentPaths\n        ];\n      }\n    }\n\n    return fragmentPathMap;\n  }\n}\n\n/**\n * Walk the document add rewrite nodes along the way\n * @param doc\n * @param callback Called on each node, and returns a new rewritten node\n * @hidden\n */\nexport const rewriteDoc = (\n  doc: DocumentNode,\n  callback: (nodeAndVars: NodeAndVarDefs, parents: ReadonlyArray<ASTNode>) => NodeAndVarDefs\n): DocumentNode => {\n  let variableDefinitions = extractVariableDefinitions(doc);\n  const walkRecursive = (\n    curNodeAndVars: NodeAndVarDefs,\n    curParents: ReadonlyArray<ASTNode>\n  ): ASTNode => {\n    const nextNodeAndVars = callback(curNodeAndVars, curParents);\n    variableDefinitions = nextNodeAndVars.variableDefinitions;\n    const node = nextNodeAndVars.node;\n    const nextParents = [...curParents, node];\n    for (const key of Object.keys(node)) {\n      if (key === 'loc') continue;\n      const val = (node as any)[key];\n      if (Array.isArray(val)) {\n        (node as any)[key] = val.map(elm => {\n          if (typeof elm === 'object') {\n            const next: NodeAndVarDefs = {\n              variableDefinitions,\n              node: elm\n            };\n            return walkRecursive(next, nextParents);\n          }\n          return elm;\n        });\n      } else if (typeof val === 'object') {\n        const next: NodeAndVarDefs = {\n          variableDefinitions,\n          node: val\n        };\n        (node as any)[key] = walkRecursive(next, nextParents);\n      }\n    }\n    return node;\n  };\n\n  const root: NodeAndVarDefs = {\n    variableDefinitions,\n    node: doc\n  };\n  const rewrittenDoc = walkRecursive(root, []) as DocumentNode;\n  return replaceVariableDefinitions(rewrittenDoc, variableDefinitions);\n};\n\n/** @hidden */\nexport const extractVariableDefinitions = (\n  doc: DocumentNode\n): ReadonlyArray<VariableDefinitionNode> => {\n  for (const def of doc.definitions) {\n    if (def.kind === 'OperationDefinition') {\n      return def.variableDefinitions || [];\n    }\n  }\n  return [];\n};\n\n/** @hidden */\nexport const replaceVariableDefinitions = (\n  doc: DocumentNode,\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>\n): DocumentNode => {\n  const definitions = doc.definitions.map(def => {\n    if (def.kind === 'OperationDefinition') {\n      return { ...def, variableDefinitions };\n    }\n    return def;\n  });\n  return { ...doc, definitions };\n};\n\n/**\n * return the path that will be returned in the response from from the chain of parents\n */\n/** @hidden */\nexport const extractPath = (parents: ReadonlyArray<ASTNode>): ReadonlyArray<string> => {\n  const path: string[] = [];\n  parents.forEach(parent => {\n    if (parent.kind === 'Field') {\n      path.push(parent.name.value);\n    }\n  });\n  return path;\n};\n\n/** @hidden */\ninterface ResultObj {\n  [key: string]: any;\n}\n\n/** @hidden */\nexport const rewriteResultsAtPath = (\n  results: ResultObj,\n  path: ReadonlyArray<string>,\n  callback: (parentResult: any, key: string, position?: number) => any\n): ResultObj => {\n  if (path.length === 0) return results;\n\n  const curPathElm = path[0];\n  const newResults = { ...results };\n  const curResults = results[curPathElm];\n\n  if (path.length === 1) {\n    if (Array.isArray(curResults)) {\n      return curResults.reduce(\n        (reducedResults, _, index) => callback(reducedResults, curPathElm, index),\n        results\n      );\n    }\n\n    return callback(results, curPathElm);\n  }\n\n  const remainingPath = path.slice(1);\n  // if the path stops here, just return results without any rewriting\n  if (curResults === undefined || curResults === null) return results;\n\n  if (Array.isArray(curResults)) {\n    newResults[curPathElm] = curResults.map(result =>\n      rewriteResultsAtPath(result, remainingPath, callback)\n    );\n  } else {\n    newResults[curPathElm] = rewriteResultsAtPath(curResults, remainingPath, callback);\n  }\n\n  return newResults;\n};\n","import { FragmentDefinitionNode, parse, print } from 'graphql';\nimport { extractPath, FragmentTracer, rewriteDoc, rewriteResultsAtPath } from './ast';\nimport Rewriter, { Variables } from './rewriters/Rewriter';\n\ninterface RewriterMatch {\n  rewriter: Rewriter;\n  paths: ReadonlyArray<ReadonlyArray<string>>;\n}\n\n/**\n * Create a new instance of this class for each request that needs to be processed\n * This class handles rewriting the query and the reponse according to the rewriters passed in\n */\nexport default class RewriteHandler {\n  public matches: RewriterMatch[] = [];\n\n  private rewriters: Rewriter[];\n  private hasProcessedRequest: boolean = false;\n  private hasProcessedResponse: boolean = false;\n\n  constructor(rewriters: Rewriter[]) {\n    this.rewriters = rewriters;\n  }\n\n  /**\n   * Call this on a graphQL request in middleware before passing on to the real graphql processor\n   * @param query The graphQL query\n   * @param variables The variables map for the graphQL query\n   */\n  public rewriteRequest(query: string, variables?: Variables) {\n    if (this.hasProcessedRequest) throw new Error('This handler has already rewritten a request');\n    this.hasProcessedRequest = true;\n    const doc = parse(query);\n    const fragmentTracer = new FragmentTracer(doc);\n    let rewrittenVariables = variables;\n    const rewrittenDoc = rewriteDoc(doc, (nodeAndVars, parents) => {\n      let rewrittenNodeAndVars = nodeAndVars;\n      this.rewriters.forEach(rewriter => {\n        const isMatch = rewriter.matches(nodeAndVars, parents);\n        if (isMatch) {\n          rewrittenVariables = rewriter.rewriteVariables(rewrittenNodeAndVars, rewrittenVariables);\n          rewrittenNodeAndVars = rewriter.rewriteQuery(rewrittenNodeAndVars, rewrittenVariables);\n          const simplePath = extractPath([...parents, rewrittenNodeAndVars.node]);\n          let paths: ReadonlyArray<ReadonlyArray<string>> = [simplePath];\n          const fragmentDef = parents.find(({ kind }) => kind === 'FragmentDefinition') as\n            | FragmentDefinitionNode\n            | undefined;\n          if (fragmentDef) {\n            paths = fragmentTracer.prependFragmentPaths(fragmentDef.name.value, simplePath);\n          }\n          this.matches.push({\n            rewriter,\n            paths\n          });\n        }\n        return isMatch;\n      });\n      return rewrittenNodeAndVars;\n    });\n\n    return { query: print(rewrittenDoc), variables: rewrittenVariables };\n  }\n\n  /**\n   * Call this on the response returned from graphQL before passing it back to the client\n   * This will change the output to match what the original query requires\n   * @param response The graphQL response object\n   */\n  public rewriteResponse(response: any) {\n    if (this.hasProcessedResponse) throw new Error('This handler has already returned a response');\n    this.hasProcessedResponse = true;\n    let rewrittenResponse = response;\n    this.matches.reverse().forEach(({ rewriter, paths }) => {\n      paths.forEach(path => {\n        rewrittenResponse = rewriteResultsAtPath(\n          rewrittenResponse,\n          path,\n          (parentResponse, key, index) => rewriter.rewriteResponse(parentResponse, key, index)\n        );\n      });\n    });\n    return rewrittenResponse;\n  }\n}\n","import { ASTNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport matchCondition from '../matchConditions/matchCondition';\n\nexport type Variables = { [key: string]: any } | undefined;\nexport type RootType = 'query' | 'mutation' | 'fragment';\n\nexport interface RewriterOpts {\n  fieldName?: string;\n  rootTypes?: RootType[];\n  matchConditions?: matchCondition[];\n}\n\n/**\n * Abstract base Rewriter class\n * Extend this class and overwrite its methods to create a new rewriter\n */\nabstract class Rewriter {\n  protected rootTypes: RootType[] = ['query', 'mutation', 'fragment'];\n  protected fieldName?: string;\n  protected matchConditions?: matchCondition[];\n\n  constructor({ fieldName, rootTypes, matchConditions }: RewriterOpts) {\n    this.fieldName = fieldName;\n    this.matchConditions = matchConditions;\n    if (!this.fieldName && !this.matchConditions) {\n      throw new Error(\n        'Neither a fieldName or matchConditions were provided. Please choose to pass either one in order to be able to detect which fields to rewrite.'\n      );\n    }\n    if (rootTypes) this.rootTypes = rootTypes;\n  }\n\n  public matches(nodeAndVarDefs: NodeAndVarDefs, parents: ReadonlyArray<ASTNode>): boolean {\n    const { node } = nodeAndVarDefs;\n\n    // If no fieldName is provided, check for defined matchConditions.\n    // This avoids having to define one rewriter for many fields individually.\n    // Alternatively, regex matching for fieldName could be implemented.\n    if (\n      node.kind !== 'Field' ||\n      (this.fieldName ? node.name.value !== this.fieldName : !this.matchConditions)\n    ) {\n      return false;\n    }\n    const root = parents[0];\n    if (\n      root.kind === 'OperationDefinition' &&\n      this.rootTypes.indexOf(root.operation as RootType) === -1\n    ) {\n      return false;\n    }\n    if (root.kind === 'FragmentDefinition' && this.rootTypes.indexOf('fragment') === -1) {\n      return false;\n    }\n    if (\n      this.matchConditions &&\n      !this.matchConditions.find(condition => condition(nodeAndVarDefs, parents))\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs, variables: Variables): NodeAndVarDefs {\n    return nodeAndVarDefs;\n  }\n\n  public rewriteVariables(nodeAndVarDefs: NodeAndVarDefs, variables: Variables): Variables {\n    return variables;\n  }\n\n  /*\n   * Receives the parent object of the matched field with the key of the matched field.\n   * For arrays, the index of the element is also present.\n   */\n  public rewriteResponse(response: any, key: string, index?: number): any {\n    return response;\n  }\n\n  /*\n   * Helper that extracts the element from the response if possible otherwise returns null.\n   */\n  protected extractReponseElement(response: any, key: string, index?: number): any {\n    // Verify the response format\n    let element = null;\n    if (response === null || typeof response !== 'object') return element;\n\n    // Extract the key\n    element = response[key] || null;\n\n    // Extract the position\n    if (Array.isArray(element)) {\n      element = element[index!] || null;\n    }\n\n    return element;\n  }\n\n  /*\n   * Helper that rewrite the element from the response if possible and returns the response.\n   */\n  protected rewriteResponseElement(\n    response: any,\n    newElement: any,\n    key: string,\n    index?: number\n  ): any {\n    // Verify the response format\n    if (response === null || typeof response !== 'object') return response;\n\n    // Extract the key\n    const element = response[key];\n\n    // Extract the position\n    // NOTE: We might eventually want to create an array if one is not present at the key\n    // and we receive an index in input\n    if (Array.isArray(element)) {\n      element[index!] = newElement;\n    } else {\n      response[key] = newElement;\n    }\n\n    return response;\n  }\n}\n\nexport default Rewriter;\n","import { ASTNode, FieldNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface IFieldArgNameRewriterOpts extends RewriterOpts {\n  oldArgName: string;\n  newArgName: string;\n}\n\n/**\n * Rewriter which replaces the name of a single argument of a field\n * ex: change from thingID: ID! to thingId: ID!\n */\nclass FieldArgNameRewriter extends Rewriter {\n  protected oldArgName: string;\n  protected newArgName: string;\n\n  constructor(options: IFieldArgNameRewriterOpts) {\n    super(options);\n    this.oldArgName = options.oldArgName;\n    this.newArgName = options.newArgName;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // is this a field with the correct arguments?\n    if (!node.arguments) return false;\n    // is there an argument with the correct name?\n    return !!node.arguments.find(arg => arg.name.value === this.oldArgName);\n  }\n\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\n    const newArguments = ((node as FieldNode).arguments || []).map(argument => {\n      if (argument.name.value === this.oldArgName) {\n        return { ...argument, name: { ...argument.name, value: this.newArgName } };\n      }\n      return argument;\n    });\n    return { variableDefinitions, node: { ...node, arguments: newArguments } } as NodeAndVarDefs;\n  }\n}\n\nexport default FieldArgNameRewriter;\n","import { ArgumentNode, ASTNode, FieldNode, ObjectFieldNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface FieldArgsToInputTypeRewriterOpts extends RewriterOpts {\n  argNames: string[];\n  inputArgName?: string;\n}\n\n/**\n * Rewriter which replaces the args to a field with an input type\n * ex: change from field(id: $id, arg2: $arg2) to field(input: { id: $id, arg2: $arg2 })\n */\nclass FieldArgsToInputTypeRewriter extends Rewriter {\n  protected argNames: string[];\n  protected inputArgName: string = 'input';\n\n  constructor(options: FieldArgsToInputTypeRewriterOpts) {\n    super(options);\n    this.fieldName = options.fieldName;\n    this.argNames = options.argNames;\n    if (options.inputArgName) this.inputArgName = options.inputArgName;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // is this a field with the correct fieldName and arguments?\n    if (node.name.value !== this.fieldName || !node.arguments) return false;\n    // if there's already an input type in this field, skip it\n    if (node.arguments.find(arg => arg.name.value === this.inputArgName)) {\n      return false;\n    }\n    // is there an argument with the correct name?\n    return !!node.arguments.find(arg => this.argNames.indexOf(arg.name.value) >= 0);\n  }\n\n  public rewriteQuery({ node, variableDefinitions }: NodeAndVarDefs) {\n    const argsToNest = ((node as FieldNode).arguments || []).filter(\n      argument => this.argNames.indexOf(argument.name.value) >= 0\n    );\n    const newArguments = ((node as FieldNode).arguments || []).filter(\n      argument => this.argNames.indexOf(argument.name.value) === -1\n    );\n    const inputArgument: ArgumentNode = {\n      kind: 'Argument',\n      name: { kind: 'Name', value: this.inputArgName },\n      value: {\n        kind: 'ObjectValue',\n        fields: argsToNest.map(\n          (arg): ObjectFieldNode => ({\n            kind: 'ObjectField',\n            name: arg.name,\n            value: arg.value\n          })\n        )\n      }\n    };\n    newArguments.push(inputArgument);\n    return { variableDefinitions, node: { ...node, arguments: newArguments } } as NodeAndVarDefs;\n  }\n}\n\nexport default FieldArgsToInputTypeRewriter;\n","import {\n  ArgumentNode,\n  ASTNode,\n  FieldNode,\n  isValueNode,\n  Kind,\n  ObjectFieldNode,\n  parseType,\n  TypeNode,\n  ValueNode,\n  VariableNode\n} from 'graphql';\nimport Maybe from 'graphql/tsutils/Maybe';\nimport { NodeAndVarDefs, nodesMatch } from '../ast';\nimport { identifyFunc } from '../utils';\nimport Rewriter, { RewriterOpts, Variables } from './Rewriter';\n\ninterface FieldArgTypeRewriterOpts extends RewriterOpts {\n  root?: string;\n  argName: string;\n  oldType: string;\n  newType: string;\n  coerceVariable?: (variable: any, context: { variables: Variables; args: ArgumentNode[] }) => any;\n  /**\n   * EXPERIMENTAL:\n   *  This allows to coerce value of argument when their value is not stored in a variable\n   *  but comes in the query node itself.\n   *  NOTE: At the moment, the user has to return the ast value node herself.\n   */\n  coerceArgumentValue?: (\n    variable: any,\n    context: { variables: Variables; args: ArgumentNode[] }\n  ) => Maybe<ValueNode>;\n}\n\n/**\n * Rewriter which replaces the type of a single argument of a field\n * ex: change from id: String! to id: ID!\n */\nclass FieldArgTypeRewriter extends Rewriter {\n  protected argName: string;\n  protected root?: string;\n  protected oldTypeNode: TypeNode;\n  protected newTypeNode: TypeNode;\n  // Passes context with rest of arguments and variables.\n  // Quite useful for variable coercion that depends on other arguments/variables\n  // (e.g., [offset, limit] to [pageSize, pageNumber] coercion)\n  protected coerceVariable: (\n    variable: any,\n    context: { variables: Variables; args: ArgumentNode[] }\n  ) => any;\n  // (Experimental): Used to coerce arguments whose value\n  // does not come in a variable.\n  protected coerceArgumentValue: (\n    variable: any,\n    context: { variables: Variables; args: ArgumentNode[] }\n  ) => Maybe<ValueNode>;\n\n  constructor(options: FieldArgTypeRewriterOpts) {\n    super(options);\n    this.root = options.root;\n    this.argName = options.argName;\n    this.oldTypeNode = parseType(options.oldType);\n    this.newTypeNode = parseType(options.newType);\n    this.coerceVariable = options.coerceVariable || identifyFunc;\n    this.coerceArgumentValue = options.coerceArgumentValue || identifyFunc;\n  }\n\n  private getMatchingArgument(node: FieldNode) {\n    if (this.root) {\n      const rootNode = (node.arguments || []).find(arg => arg.name.value === this.root);\n      if (!rootNode) return undefined;\n      if (rootNode.value.kind === 'ObjectValue') {\n        return rootNode.value.fields.find(field => field.name.value === this.argName);\n      }\n    } else {\n      return (node.arguments || []).find(arg => arg.name.value === this.argName);\n    }\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    const { variableDefinitions } = nodeAndVars;\n    // is this a field with the correct fieldName and arguments?\n    if (node.kind !== 'Field') return false;\n\n    // does this field contain arguments?\n    if (!node.arguments) return false;\n\n    const matchingArgument = this.getMatchingArgument(node);\n\n    if (!matchingArgument) return false;\n\n    // argument value is stored in a variable\n    if (matchingArgument.value.kind === 'Variable') {\n      const varRef = matchingArgument.value.name.value;\n      // does the referenced variable have the correct type?\n      for (const varDefinition of variableDefinitions) {\n        if (varDefinition.variable.name.value === varRef) {\n          return nodesMatch(this.oldTypeNode, varDefinition.type);\n        }\n      }\n    }\n    // argument value comes in query doc.\n    else {\n      const argValueNode = matchingArgument.value;\n      return isValueNode(argValueNode);\n      // Would be ideal to do a nodesMatch in here, however argument value nodes\n      // have different format for their values than when passed as variables.\n      // For instance, are parsed with Kinds as \"graphql.Kind\" (e.g., INT=\"IntValue\") and not \"graphql.TokenKinds\" (e.g., INT=\"Int\")\n      // So they might not match correctly. Also they dont contain additional parsed syntax\n      // as the non-optional symbol \"!\". So just return true if the argument.value is a ValueNode.\n      //\n      // return nodesMatch(this.oldTypeNode, parseType(argRef.kind));\n    }\n\n    return false;\n  }\n\n  public rewriteQuery(\n    { node: astNode, variableDefinitions }: NodeAndVarDefs,\n    variables: Variables\n  ) {\n    const node = astNode as FieldNode;\n    const varRefName = this.extractMatchingVarRefName(node);\n    // If argument value is stored in a variable\n    if (varRefName) {\n      const newVarDefs = variableDefinitions.map(varDef => {\n        if (varDef.variable.name.value !== varRefName) return varDef;\n        return { ...varDef, type: this.newTypeNode };\n      });\n      return { node, variableDefinitions: newVarDefs };\n    }\n    // If argument value is not stored in a variable but in the query node.\n    const matchingArgument = this.getMatchingArgument(node);\n    if (node.arguments && matchingArgument) {\n      const args = [...node.arguments];\n      const newValue = this.coerceArgumentValue(matchingArgument.value, { variables, args });\n      /**\n       * TODO: If somewhow we can get the schema here, we could make the coerceArgumentValue\n       * even easier, as we would be able to construct the ast node for the argument value.\n       * as of now, the user has to take care of correctly constructing the argument value ast node herself.\n       *\n       * const schema = makeExecutableSchema({typeDefs})\n       * const myCustomType = schema.getType(\"MY_CUSTOM_TYPE_NAME\")\n       * const newArgValue = astFromValue(newValue, myCustomType)\n       * Object.assign(matchingArgument, { value: newArgValue })\n       */\n      if (newValue) Object.assign(matchingArgument, { value: newValue });\n    }\n    return { node, variableDefinitions };\n  }\n\n  public rewriteVariables({ node: astNode }: NodeAndVarDefs, variables: Variables) {\n    const node = astNode as FieldNode;\n    if (!variables) return variables;\n    const varRefName = this.extractMatchingVarRefName(node);\n    const args = [...(node.arguments ? node.arguments : [])];\n    return {\n      ...variables,\n      ...(varRefName\n        ? { [varRefName]: this.coerceVariable(variables[varRefName], { variables, args }) }\n        : {})\n    };\n  }\n\n  private extractMatchingVarRefName(node: FieldNode) {\n    const matchingArgument = this.getMatchingArgument(node)!;\n    const variableNode = matchingArgument.value as VariableNode;\n    return variableNode.kind === Kind.VARIABLE && variableNode.name.value;\n  }\n}\n\nexport default FieldArgTypeRewriter;\n","import { ASTNode, FieldNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface NestFieldOutputsRewriterOpts extends RewriterOpts {\n  newOutputName: string;\n  outputsToNest: string[];\n}\n\n/**\n * Rewriter which nests output fields inside of a new output object\n * ex: change from `field { output1, output2 }` to `field { nestedOutputs { output1, output 2 } }`\n */\nclass NestFieldOutputsRewriter extends Rewriter {\n  protected newOutputName: string;\n  protected outputsToNest: string[];\n\n  constructor(options: NestFieldOutputsRewriterOpts) {\n    super(options);\n    this.newOutputName = options.newOutputName;\n    this.outputsToNest = options.outputsToNest;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]) {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // is this a field with the correct selections?\n    if (!node.selectionSet) return false;\n    // if `newOutputName` already exists as an output, skip it\n    if (\n      node.selectionSet.selections.find(\n        output => output.kind === 'Field' && output.name.value === this.newOutputName\n      )\n    ) {\n      return false;\n    }\n    // is there an output with a matching name?\n    return !!node.selectionSet.selections.find(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) >= 0\n    );\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs) {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    if (!node.selectionSet) return nodeAndVarDefs;\n    const outputsToNest = (node.selectionSet.selections || []).filter(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) >= 0\n    );\n    const newOutputs = (node.selectionSet.selections || []).filter(\n      output => output.kind === 'Field' && this.outputsToNest.indexOf(output.name.value) === -1\n    );\n    const nestedOutput: FieldNode = {\n      kind: 'Field',\n      name: { kind: 'Name', value: this.newOutputName },\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: outputsToNest\n      }\n    };\n    newOutputs.push(nestedOutput);\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet: { ...node.selectionSet, selections: newOutputs } }\n    } as NodeAndVarDefs;\n  }\n\n  public rewriteResponse(response: any, key: string, index?: number) {\n    // Extract the element we are working on\n    const element = super.extractReponseElement(response, key, index);\n    if (element === null || typeof element !== 'object') return response;\n\n    // Undo the nesting in the response so it matches the original query\n    if (element[this.newOutputName] && typeof element[this.newOutputName] === 'object') {\n      const newElement = { ...element, ...element[this.newOutputName] };\n      delete newElement[this.newOutputName];\n\n      return super.rewriteResponseElement(response, newElement, key, index);\n    }\n\n    return response;\n  }\n}\n\nexport default NestFieldOutputsRewriter;\n","import { ASTNode, FieldNode, SelectionSetNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface ScalarFieldToObjectFieldRewriterOpts extends RewriterOpts {\n  objectFieldName: string;\n}\n\n/**\n * Rewriter which nests a scalar field inside of a new output object\n * ex: change from `field { subField }` to `field { subField { objectfield } }`\n */\nclass ScalarFieldToObjectFieldRewriter extends Rewriter {\n  protected objectFieldName: string;\n\n  constructor(options: ScalarFieldToObjectFieldRewriterOpts) {\n    super(options);\n    this.objectFieldName = options.objectFieldName;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]): boolean {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // make sure there's no subselections on this field\n    if (node.selectionSet) return false;\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs) {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    // if there's a subselection already, just return\n    if (node.selectionSet) return nodeAndVarDefs;\n\n    const selectionSet: SelectionSetNode = {\n      kind: 'SelectionSet',\n      selections: [\n        {\n          kind: 'Field',\n          name: { kind: 'Name', value: this.objectFieldName }\n        }\n      ]\n    };\n\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet }\n    } as NodeAndVarDefs;\n  }\n\n  public rewriteResponse(response: any, key: string, index?: number) {\n    // Extract the element we are working on\n    const element = super.extractReponseElement(response, key, index);\n    if (element === null) return response;\n\n    // Undo the nesting in the response so it matches the original query\n    const newElement = element[this.objectFieldName];\n    return super.rewriteResponseElement(response, newElement, key, index);\n  }\n}\n\nexport default ScalarFieldToObjectFieldRewriter;\n","import { ASTNode, FieldNode, SelectionSetNode } from 'graphql';\nimport { NodeAndVarDefs } from '../ast';\nimport Rewriter, { RewriterOpts } from './Rewriter';\n\ninterface ObjectField {\n  name: string;\n  subfields?: ObjectField[];\n}\n\ninterface JsonToTypedObjectRewriterOpts extends RewriterOpts {\n  objectFields: ObjectField[];\n}\n\nexport default class JsonToTypedObjectRewriter extends Rewriter {\n  protected objectFields: ObjectField[];\n\n  constructor({ fieldName, objectFields }: JsonToTypedObjectRewriterOpts) {\n    super({ fieldName });\n    this.objectFields = objectFields;\n  }\n\n  public matches(nodeAndVars: NodeAndVarDefs, parents: ASTNode[]): boolean {\n    if (!super.matches(nodeAndVars, parents)) return false;\n    const node = nodeAndVars.node as FieldNode;\n    // make sure there's no subselections on this field\n    if (node.selectionSet) return false;\n    return true;\n  }\n\n  public rewriteQuery(nodeAndVarDefs: NodeAndVarDefs): NodeAndVarDefs {\n    const node = nodeAndVarDefs.node as FieldNode;\n    const { variableDefinitions } = nodeAndVarDefs;\n    // if there's a subselection already, just return\n    if (node.selectionSet) return nodeAndVarDefs;\n\n    const selectionSet = this.generateSelectionSet(this.objectFields);\n\n    return {\n      variableDefinitions,\n      node: { ...node, selectionSet }\n    } as NodeAndVarDefs;\n  }\n\n  private generateSelectionSet(fields: ObjectField[]): SelectionSetNode {\n    return {\n      kind: 'SelectionSet',\n      selections: fields.map(({ name, subfields }) => ({\n        kind: 'Field',\n        name: { kind: 'Name', value: name },\n        ...(subfields && {\n          selectionSet: this.generateSelectionSet(subfields)\n        })\n      }))\n    } as SelectionSetNode;\n  }\n}\n","import { FragmentDefinitionNode } from 'graphql';\nimport { extractPath } from '../ast';\nimport matchCondition from './matchCondition';\nexport interface FragmentMatchConditionOpts {\n  fragmentNames?: string[];\n  fragmentTypes?: string[];\n  pathRegexes?: RegExp[];\n}\n\nconst fragmentMatchCondition = ({\n  fragmentNames,\n  fragmentTypes,\n  pathRegexes\n}: FragmentMatchConditionOpts = {}): matchCondition => {\n  return ({ node }, parents) => {\n    const fragmentDef = parents.find(({ kind }) => kind === 'FragmentDefinition') as\n      | FragmentDefinitionNode\n      | undefined;\n    if (!fragmentDef) return false;\n\n    if (fragmentNames && !fragmentNames.includes(fragmentDef.name.value)) {\n      return false;\n    }\n\n    if (fragmentTypes && !fragmentTypes.includes(fragmentDef.typeCondition.name.value)) {\n      return false;\n    }\n\n    if (pathRegexes) {\n      const pathStr = extractPath([...parents, node]).join('.');\n      if (!pathRegexes.find(pathRegex => pathRegex.test(pathStr))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n};\n\nexport default fragmentMatchCondition;\n","import { OperationDefinitionNode } from 'graphql';\nimport { extractPath } from '../ast';\nimport matchCondition from './matchCondition';\n\n/** @hidden */\nexport interface OperationMatchConditionOpts {\n  operationNames?: string[];\n  operationTypes?: string[];\n  pathRegexes?: RegExp[];\n}\n\n/** @hidden */\nexport default ({\n  operationNames,\n  operationTypes,\n  pathRegexes\n}: OperationMatchConditionOpts = {}): matchCondition => {\n  return ({ node }, parents) => {\n    const operationDef = parents.find(({ kind }) => kind === 'OperationDefinition') as\n      | OperationDefinitionNode\n      | undefined;\n\n    if (!operationDef) return false;\n\n    if (operationNames) {\n      if (!operationDef.name || !operationNames.includes(operationDef.name.value)) {\n        return false;\n      }\n    }\n\n    if (operationTypes && !operationTypes.includes(operationDef.operation)) {\n      return false;\n    }\n\n    if (pathRegexes) {\n      const pathStr = extractPath([...parents, node]).join('.');\n      if (!pathRegexes.find(pathRegex => pathRegex.test(pathStr))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n};\n","import matchCondition from './matchCondition';\nimport operationMatchCondition from './operationMatchCondition';\nexport interface QueryMatchConditionOpts {\n  queryNames?: string[];\n  pathRegexes?: RegExp[];\n}\n\nconst queryMatchCondition = ({\n  queryNames,\n  pathRegexes\n}: QueryMatchConditionOpts = {}): matchCondition => {\n  return operationMatchCondition({\n    pathRegexes,\n    operationNames: queryNames,\n    operationTypes: ['query']\n  });\n};\n\nexport default queryMatchCondition;\n","import matchCondition from './matchCondition';\nimport operationMatchCondition from './operationMatchCondition';\nexport interface MutationMatchConditionOpts {\n  mutationNames?: string[];\n  pathRegexes?: RegExp[];\n}\n\nconst mutationMatchCondition = ({\n  mutationNames,\n  pathRegexes\n}: MutationMatchConditionOpts = {}): matchCondition => {\n  return operationMatchCondition({\n    pathRegexes,\n    operationNames: mutationNames,\n    operationTypes: ['mutation']\n  });\n};\n\nexport default mutationMatchCondition;\n"],"names":["parse","print","tslib_1.__extends","parseType","isValueNode","Kind"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAAA;AACA,IAAO,IAAM,YAAY,GAAG,UAAI,GAAM,IAAK,OAAA,GAAG,GAAA,CAAC;IAE/C;AACA,IAAO,IAAM,gBAAgB,GAAG,UAAI,OAA+B,EAAE,GAAW,EAAE,GAAM;QACtF,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;YAAE,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;QACrC,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACzB,CAAC,CAAC;;ICJF,IAAM,UAAU,GAAG,IAAI,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IAEpC;AACA,IAAO,IAAM,UAAU,GAAG,UAAC,KAAc,EAAE,KAAc;QACvD,KAAkB,UAAkB,EAAlB,KAAA,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAlB,cAAkB,EAAlB,IAAkB,EAAE;YAAjC,IAAM,GAAG,SAAA;YACZ,IAAI,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC;gBAAE,SAAS;YAClC,IAAM,IAAI,GAAI,KAAa,CAAC,GAAG,CAAC,CAAC;YACjC,IAAM,IAAI,GAAI,KAAa,CAAC,GAAG,CAAC,CAAC;YACjC,IAAI,IAAI,IAAI,CAAC,IAAI;gBAAE,OAAO,KAAK,CAAC;YAChC,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACvB,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM;oBAAE,OAAO,KAAK,CAAC;gBAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACpC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;wBAAE,OAAO,KAAK,CAAC;iBACjD;aACF;iBAAM,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;gBACnC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC;oBAAE,OAAO,KAAK,CAAC;aAC3C;iBAAM,IAAI,IAAI,KAAK,IAAI,EAAE;gBACxB,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;IAkBF;IACA;QAIE,wBAAY,GAAiB;YAC3B,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;SAChB;QAEM,2CAAkB,GAAzB,UAA0B,YAAoB;YAC5C,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;gBACzB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;aACpD;YACD,OAAO,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;SACjD;;QAGM,6CAAoB,GAA3B,UACE,YAAoB,EACpB,kBAAyC;YAEzC,OAAO,IAAI,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAI,IAAI,QAAK,kBAAkB,IAAC,CAAC,CAAC;SAC5F;QAEO,wCAAe,GAAvB;YACE,OAAO,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,MAAM,CAChC,UAAC,EAAQ;oBAAN,cAAI;gBAAO,OAAA,IAAI,KAAK,oBAAoB;aAAA,CAChB,CAAC;SAC/B;QAEO,kDAAyB,GAAjC,UAAkC,SAAkB;YAClD,IAAM,cAAc,GAA2B,EAAE,CAAC;YAClD,IAAM,6BAA6B,GAAG,UAAC,IAAa,EAAE,UAAkC;gBACtF,IAAI,IAAI,CAAC,IAAI,KAAK,gBAAgB,EAAE;oBAClC,gBAAgB,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC;iBAC5E;gBACD,IAAM,WAAW,GAAO,UAAU,SAAE,IAAI,EAAC,CAAC;gBAC1C,IAAI,cAAc,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,EAAE;oBAC/C,KAAwB,UAA4B,EAA5B,KAAA,IAAI,CAAC,YAAY,CAAC,UAAU,EAA5B,cAA4B,EAA5B,IAA4B,EAAE;wBAAjD,IAAM,SAAS,SAAA;wBAClB,6BAA6B,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;qBACvD;iBACF;aACF,CAAC;YACF,6BAA6B,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;YAC7C,OAAO,cAAc,CAAC;SACvB;QAEO,2CAAkB,GAA1B,UACE,YAAoB,EACpB,KAAmC,EACnC,uBAAoE;YAEpE,IAAM,WAAW,GAA2B,EAAE,CAAC;YAE/C,IAAM,8BAA8B,GAAG,UACrC,eAAuB,EACvB,QAAsC,EACtC,aAAkC;;gBAGlC,IAAI,aAAa,CAAC,GAAG,CAAC,eAAe,CAAC;oBAAE,OAAO;gBAC/C,IAAM,iBAAiB,GAAG,IAAI,GAAG,CAAC,aAAa,CAAC,CAAC;gBACjD,iBAAiB,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;gBACvC,IAAM,gBAAgB,GAAG,uBAAuB,CAAC,eAAe,CAAC,CAAC;;gBAElE,IAAI,CAAC,gBAAgB;oBAAE,OAAO;gBAE9B,KAAsD,UAAgC,EAAhC,KAAA,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAhC,cAAgC,EAAhC,IAAgC,EAAE;oBAA7E,IAAA,WAAuC,EAAtC,yBAAiB,EAAE,0BAAkB;oBAC/C,KAAmB,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ,EAAE;wBAAxB,IAAM,IAAI,iBAAA;wBACb,IAAM,gBAAgB,GAAiC,EAAE,CAAC;wBAC1D,KAAwB,UAAkB,EAAlB,yCAAkB,EAAlB,gCAAkB,EAAlB,IAAkB,EAAE;4BAAvC,IAAM,SAAS,2BAAA;4BAClB,IAAM,UAAU,GAAO,IAAI,QAAK,SAAS,CAAC,CAAC;4BAC3C,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;4BAClC,gBAAgB,CAAC,WAAW,EAAE,iBAAiB,EAAE,UAAU,CAAC,CAAC;yBAC9D;wBACD,8BAA8B,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,iBAAiB,CAAC,CAAC;qBACxF;iBACF;aACF,CAAC;YAEF,8BAA8B,CAAC,YAAY,EAAE,KAAK,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;YAC/D,OAAO,WAAW,CAAC;SACpB;QAEO,6CAAoB,GAA5B;YACE,IAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,IAAI,KAAK,qBAAqB,GAAA,CAAC,CAAC;YAC7F,IAAI,CAAC,aAAa;gBAAE,OAAO,EAAE,CAAC;;YAG9B,IAAM,uBAAuB,GAAgD,EAAE,CAAC;YAChF,KAA0B,UAAsB,EAAtB,KAAA,IAAI,CAAC,eAAe,EAAE,EAAtB,cAAsB,EAAtB,IAAsB,EAAE;gBAA7C,IAAM,WAAW,SAAA;gBACpB,uBAAuB,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,yBAAyB,CAAC,WAAW,CAAC,CAAC;aAC/F;;YAGD,IAAM,qBAAqB,GAA2B,IAAI,CAAC,yBAAyB,CAClF,aAAa,CACd,CAAC;YACF,IAAM,eAAe,gBAAgC,qBAAqB,CAAE,CAAC;;YAE7E,KAA0C,UAAqC,EAArC,KAAA,MAAM,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAArC,cAAqC,EAArC,IAAqC,EAAE;gBAAtE,IAAA,WAA2B,EAA1B,oBAAY,EAAE,mBAAW;gBACnC,IAAM,sBAAsB,GAAG,IAAI,CAAC,kBAAkB,CACpD,YAAY,EACZ,WAAW,EACX,uBAAuB,CACxB,CAAC;gBACF,KAAwD,UAEvD,EAFuD,KAAA,MAAM,CAAC,OAAO,CACpE,sBAAsB,CACvB,EAFuD,cAEvD,EAFuD,IAEvD,EAAE;oBAFQ,IAAA,WAAyC,EAAxC,0BAAkB,EAAE,2BAAmB;oBAGjD,eAAe,CAAC,kBAAkB,CAAC,GAC9B,CAAC,eAAe,CAAC,kBAAkB,CAAC,IAAI,EAAE,SAC1C,mBAAmB,CACvB,CAAC;iBACH;aACF;YAED,OAAO,eAAe,CAAC;SACxB;QACH,qBAAC;IAAD,CAAC,IAAA;IAED;;;;;;AAMA,IAAO,IAAM,UAAU,GAAG,UACxB,GAAiB,EACjB,QAA0F;QAE1F,IAAI,mBAAmB,GAAG,0BAA0B,CAAC,GAAG,CAAC,CAAC;QAC1D,IAAM,aAAa,GAAG,UACpB,cAA8B,EAC9B,UAAkC;YAElC,IAAM,eAAe,GAAG,QAAQ,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;YAC7D,mBAAmB,GAAG,eAAe,CAAC,mBAAmB,CAAC;YAC1D,IAAM,IAAI,GAAG,eAAe,CAAC,IAAI,CAAC;YAClC,IAAM,WAAW,GAAO,UAAU,SAAE,IAAI,EAAC,CAAC;YAC1C,KAAkB,UAAiB,EAAjB,KAAA,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAjB,cAAiB,EAAjB,IAAiB,EAAE;gBAAhC,IAAM,GAAG,SAAA;gBACZ,IAAI,GAAG,KAAK,KAAK;oBAAE,SAAS;gBAC5B,IAAM,GAAG,GAAI,IAAY,CAAC,GAAG,CAAC,CAAC;gBAC/B,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;oBACrB,IAAY,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,UAAA,GAAG;wBAC9B,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;4BAC3B,IAAM,IAAI,GAAmB;gCAC3B,mBAAmB,qBAAA;gCACnB,IAAI,EAAE,GAAG;6BACV,CAAC;4BACF,OAAO,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;yBACzC;wBACD,OAAO,GAAG,CAAC;qBACZ,CAAC,CAAC;iBACJ;qBAAM,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;oBAClC,IAAM,IAAI,GAAmB;wBAC3B,mBAAmB,qBAAA;wBACnB,IAAI,EAAE,GAAG;qBACV,CAAC;oBACD,IAAY,CAAC,GAAG,CAAC,GAAG,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;iBACvD;aACF;YACD,OAAO,IAAI,CAAC;SACb,CAAC;QAEF,IAAM,IAAI,GAAmB;YAC3B,mBAAmB,qBAAA;YACnB,IAAI,EAAE,GAAG;SACV,CAAC;QACF,IAAM,YAAY,GAAG,aAAa,CAAC,IAAI,EAAE,EAAE,CAAiB,CAAC;QAC7D,OAAO,0BAA0B,CAAC,YAAY,EAAE,mBAAmB,CAAC,CAAC;IACvE,CAAC,CAAC;IAEF;AACA,IAAO,IAAM,0BAA0B,GAAG,UACxC,GAAiB;QAEjB,KAAkB,UAAe,EAAf,KAAA,GAAG,CAAC,WAAW,EAAf,cAAe,EAAf,IAAe,EAAE;YAA9B,IAAM,GAAG,SAAA;YACZ,IAAI,GAAG,CAAC,IAAI,KAAK,qBAAqB,EAAE;gBACtC,OAAO,GAAG,CAAC,mBAAmB,IAAI,EAAE,CAAC;aACtC;SACF;QACD,OAAO,EAAE,CAAC;IACZ,CAAC,CAAC;IAEF;AACA,IAAO,IAAM,0BAA0B,GAAG,UACxC,GAAiB,EACjB,mBAA0D;QAE1D,IAAM,WAAW,GAAG,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,UAAA,GAAG;YACzC,IAAI,GAAG,CAAC,IAAI,KAAK,qBAAqB,EAAE;gBACtC,oBAAY,GAAG,IAAE,mBAAmB,qBAAA,IAAG;aACxC;YACD,OAAO,GAAG,CAAC;SACZ,CAAC,CAAC;QACH,oBAAY,GAAG,IAAE,WAAW,aAAA,IAAG;IACjC,CAAC,CAAC;IAEF;;;IAGA;AACA,IAAO,IAAM,WAAW,GAAG,UAAC,OAA+B;QACzD,IAAM,IAAI,GAAa,EAAE,CAAC;QAC1B,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;YACpB,IAAI,MAAM,CAAC,IAAI,KAAK,OAAO,EAAE;gBAC3B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAC9B;SACF,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;IAOF;AACA,IAAO,IAAM,oBAAoB,GAAG,UAClC,OAAkB,EAClB,IAA2B,EAC3B,QAAoE;QAEpE,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,OAAO,CAAC;QAEtC,IAAM,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QAC3B,IAAM,UAAU,gBAAQ,OAAO,CAAE,CAAC;QAClC,IAAM,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;QAEvC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;YACrB,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;gBAC7B,OAAO,UAAU,CAAC,MAAM,CACtB,UAAC,cAAc,EAAE,CAAC,EAAE,KAAK,IAAK,OAAA,QAAQ,CAAC,cAAc,EAAE,UAAU,EAAE,KAAK,CAAC,GAAA,EACzE,OAAO,CACR,CAAC;aACH;YAED,OAAO,QAAQ,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;SACtC;QAED,IAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;;QAEpC,IAAI,UAAU,KAAK,SAAS,IAAI,UAAU,KAAK,IAAI;YAAE,OAAO,OAAO,CAAC;QAEpE,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;YAC7B,UAAU,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,UAAA,MAAM;gBAC5C,OAAA,oBAAoB,CAAC,MAAM,EAAE,aAAa,EAAE,QAAQ,CAAC;aAAA,CACtD,CAAC;SACH;aAAM;YACL,UAAU,CAAC,UAAU,CAAC,GAAG,oBAAoB,CAAC,UAAU,EAAE,aAAa,EAAE,QAAQ,CAAC,CAAC;SACpF;QAED,OAAO,UAAU,CAAC;IACpB,CAAC,CAAC;;IC9RF;;;;IAIA;QAOE,wBAAY,SAAqB;YAN1B,YAAO,GAAoB,EAAE,CAAC;YAG7B,wBAAmB,GAAY,KAAK,CAAC;YACrC,yBAAoB,GAAY,KAAK,CAAC;YAG5C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;SAC5B;;;;;;QAOM,uCAAc,GAArB,UAAsB,KAAa,EAAE,SAAqB;YAA1D,iBAgCC;YA/BC,IAAI,IAAI,CAAC,mBAAmB;gBAAE,MAAM,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;YAC9F,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAChC,IAAM,GAAG,GAAGA,aAAK,CAAC,KAAK,CAAC,CAAC;YACzB,IAAM,cAAc,GAAG,IAAI,cAAc,CAAC,GAAG,CAAC,CAAC;YAC/C,IAAI,kBAAkB,GAAG,SAAS,CAAC;YACnC,IAAM,YAAY,GAAG,UAAU,CAAC,GAAG,EAAE,UAAC,WAAW,EAAE,OAAO;gBACxD,IAAI,oBAAoB,GAAG,WAAW,CAAC;gBACvC,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ;oBAC7B,IAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;oBACvD,IAAI,OAAO,EAAE;wBACX,kBAAkB,GAAG,QAAQ,CAAC,gBAAgB,CAAC,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;wBACzF,oBAAoB,GAAG,QAAQ,CAAC,YAAY,CAAC,oBAAoB,EAAE,kBAAkB,CAAC,CAAC;wBACvF,IAAM,UAAU,GAAG,WAAW,CAAK,OAAO,SAAE,oBAAoB,CAAC,IAAI,GAAE,CAAC;wBACxE,IAAI,KAAK,GAAyC,CAAC,UAAU,CAAC,CAAC;wBAC/D,IAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC,UAAC,EAAQ;gCAAN,cAAI;4BAAO,OAAA,IAAI,KAAK,oBAAoB;yBAAA,CAE/D,CAAC;wBACd,IAAI,WAAW,EAAE;4BACf,KAAK,GAAG,cAAc,CAAC,oBAAoB,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;yBACjF;wBACD,KAAI,CAAC,OAAO,CAAC,IAAI,CAAC;4BAChB,QAAQ,UAAA;4BACR,KAAK,OAAA;yBACN,CAAC,CAAC;qBACJ;oBACD,OAAO,OAAO,CAAC;iBAChB,CAAC,CAAC;gBACH,OAAO,oBAAoB,CAAC;aAC7B,CAAC,CAAC;YAEH,OAAO,EAAE,KAAK,EAAEC,aAAK,CAAC,YAAY,CAAC,EAAE,SAAS,EAAE,kBAAkB,EAAE,CAAC;SACtE;;;;;;QAOM,wCAAe,GAAtB,UAAuB,QAAa;YAClC,IAAI,IAAI,CAAC,oBAAoB;gBAAE,MAAM,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;YAC/F,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC;YACjC,IAAI,iBAAiB,GAAG,QAAQ,CAAC;YACjC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,UAAC,EAAmB;oBAAjB,sBAAQ,EAAE,gBAAK;gBAC/C,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI;oBAChB,iBAAiB,GAAG,oBAAoB,CACtC,iBAAiB,EACjB,IAAI,EACJ,UAAC,cAAc,EAAE,GAAG,EAAE,KAAK,IAAK,OAAA,QAAQ,CAAC,eAAe,CAAC,cAAc,EAAE,GAAG,EAAE,KAAK,CAAC,GAAA,CACrF,CAAC;iBACH,CAAC,CAAC;aACJ,CAAC,CAAC;YACH,OAAO,iBAAiB,CAAC;SAC1B;QACH,qBAAC;IAAD,CAAC,IAAA;;ICtED;;;;IAIA;QAKE,kBAAY,EAAuD;gBAArD,wBAAS,EAAE,wBAAS,EAAE,oCAAe;YAJzC,cAAS,GAAe,CAAC,OAAO,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;YAKlE,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;YACvC,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;gBAC5C,MAAM,IAAI,KAAK,CACb,+IAA+I,CAChJ,CAAC;aACH;YACD,IAAI,SAAS;gBAAE,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;SAC3C;QAEM,0BAAO,GAAd,UAAe,cAA8B,EAAE,OAA+B;YACpE,IAAA,0BAAI,CAAoB;;;;YAKhC,IACE,IAAI,CAAC,IAAI,KAAK,OAAO;iBACpB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,SAAS,GAAG,CAAC,IAAI,CAAC,eAAe,CAAC,EAC7E;gBACA,OAAO,KAAK,CAAC;aACd;YACD,IAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACxB,IACE,IAAI,CAAC,IAAI,KAAK,qBAAqB;gBACnC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,SAAqB,CAAC,KAAK,CAAC,CAAC,EACzD;gBACA,OAAO,KAAK,CAAC;aACd;YACD,IAAI,IAAI,CAAC,IAAI,KAAK,oBAAoB,IAAI,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE;gBACnF,OAAO,KAAK,CAAC;aACd;YACD,IACE,IAAI,CAAC,eAAe;gBACpB,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAA,SAAS,IAAI,OAAA,SAAS,CAAC,cAAc,EAAE,OAAO,CAAC,GAAA,CAAC,EAC3E;gBACA,OAAO,KAAK,CAAC;aACd;YACD,OAAO,IAAI,CAAC;SACb;QAEM,+BAAY,GAAnB,UAAoB,cAA8B,EAAE,SAAoB;YACtE,OAAO,cAAc,CAAC;SACvB;QAEM,mCAAgB,GAAvB,UAAwB,cAA8B,EAAE,SAAoB;YAC1E,OAAO,SAAS,CAAC;SAClB;;;;;QAMM,kCAAe,GAAtB,UAAuB,QAAa,EAAE,GAAW,EAAE,KAAc;YAC/D,OAAO,QAAQ,CAAC;SACjB;;;;QAKS,wCAAqB,GAA/B,UAAgC,QAAa,EAAE,GAAW,EAAE,KAAc;;YAExE,IAAI,OAAO,GAAG,IAAI,CAAC;YACnB,IAAI,QAAQ,KAAK,IAAI,IAAI,OAAO,QAAQ,KAAK,QAAQ;gBAAE,OAAO,OAAO,CAAC;;YAGtE,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC;;YAGhC,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC1B,OAAO,GAAG,OAAO,CAAC,KAAM,CAAC,IAAI,IAAI,CAAC;aACnC;YAED,OAAO,OAAO,CAAC;SAChB;;;;QAKS,yCAAsB,GAAhC,UACE,QAAa,EACb,UAAe,EACf,GAAW,EACX,KAAc;;YAGd,IAAI,QAAQ,KAAK,IAAI,IAAI,OAAO,QAAQ,KAAK,QAAQ;gBAAE,OAAO,QAAQ,CAAC;;YAGvE,IAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;;;;YAK9B,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;gBAC1B,OAAO,CAAC,KAAM,CAAC,GAAG,UAAU,CAAC;aAC9B;iBAAM;gBACL,QAAQ,CAAC,GAAG,CAAC,GAAG,UAAU,CAAC;aAC5B;YAED,OAAO,QAAQ,CAAC;SACjB;QACH,eAAC;IAAD,CAAC,IAAA;;ICpHD;;;;IAIA;QAAmCC,wCAAQ;QAIzC,8BAAY,OAAkC;YAA9C,YACE,kBAAM,OAAO,CAAC,SAGf;YAFC,KAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;YACrC,KAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;;SACtC;QAEM,sCAAO,GAAd,UAAe,WAA2B,EAAE,OAAkB;YAA9D,iBAOC;YANC,IAAI,CAAC,iBAAM,OAAO,YAAC,WAAW,EAAE,OAAO,CAAC;gBAAE,OAAO,KAAK,CAAC;YACvD,IAAM,IAAI,GAAG,WAAW,CAAC,IAAiB,CAAC;;YAE3C,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAO,KAAK,CAAC;;YAElC,OAAO,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,KAAI,CAAC,UAAU,GAAA,CAAC,CAAC;SACzE;QAEM,2CAAY,GAAnB,UAAoB,EAA6C;YAAjE,iBAQC;gBARqB,cAAI,EAAE,4CAAmB;YAC7C,IAAM,YAAY,GAAG,CAAE,IAAkB,CAAC,SAAS,IAAI,EAAE,EAAE,GAAG,CAAC,UAAA,QAAQ;gBACrE,IAAI,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,KAAI,CAAC,UAAU,EAAE;oBAC3C,oBAAY,QAAQ,IAAE,IAAI,eAAO,QAAQ,CAAC,IAAI,IAAE,KAAK,EAAE,KAAI,CAAC,UAAU,OAAK;iBAC5E;gBACD,OAAO,QAAQ,CAAC;aACjB,CAAC,CAAC;YACH,OAAO,EAAE,mBAAmB,qBAAA,EAAE,IAAI,eAAO,IAAI,IAAE,SAAS,EAAE,YAAY,GAAE,EAAoB,CAAC;SAC9F;QACH,2BAAC;IAAD,CA5BA,CAAmC,QAAQ,GA4B1C;;IChCD;;;;IAIA;QAA2CA,gDAAQ;QAIjD,sCAAY,OAAyC;YAArD,YACE,kBAAM,OAAO,CAAC,SAIf;YAPS,kBAAY,GAAW,OAAO,CAAC;YAIvC,KAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;YACnC,KAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;YACjC,IAAI,OAAO,CAAC,YAAY;gBAAE,KAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;;SACpE;QAEM,8CAAO,GAAd,UAAe,WAA2B,EAAE,OAAkB;YAA9D,iBAWC;YAVC,IAAI,CAAC,iBAAM,OAAO,YAAC,WAAW,EAAE,OAAO,CAAC;gBAAE,OAAO,KAAK,CAAC;YACvD,IAAM,IAAI,GAAG,WAAW,CAAC,IAAiB,CAAC;;YAE3C,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAO,KAAK,CAAC;;YAExE,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,KAAI,CAAC,YAAY,GAAA,CAAC,EAAE;gBACpE,OAAO,KAAK,CAAC;aACd;;YAED,OAAO,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,GAAG,IAAI,OAAA,KAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAA,CAAC,CAAC;SACjF;QAEM,mDAAY,GAAnB,UAAoB,EAA6C;YAAjE,iBAuBC;gBAvBqB,cAAI,EAAE,4CAAmB;YAC7C,IAAM,UAAU,GAAG,CAAE,IAAkB,CAAC,SAAS,IAAI,EAAE,EAAE,MAAM,CAC7D,UAAA,QAAQ,IAAI,OAAA,KAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAA,CAC5D,CAAC;YACF,IAAM,YAAY,GAAG,CAAE,IAAkB,CAAC,SAAS,IAAI,EAAE,EAAE,MAAM,CAC/D,UAAA,QAAQ,IAAI,OAAA,KAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,GAAA,CAC9D,CAAC;YACF,IAAM,aAAa,GAAiB;gBAClC,IAAI,EAAE,UAAU;gBAChB,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,YAAY,EAAE;gBAChD,KAAK,EAAE;oBACL,IAAI,EAAE,aAAa;oBACnB,MAAM,EAAE,UAAU,CAAC,GAAG,CACpB,UAAC,GAAG,IAAsB,QAAC;wBACzB,IAAI,EAAE,aAAa;wBACnB,IAAI,EAAE,GAAG,CAAC,IAAI;wBACd,KAAK,EAAE,GAAG,CAAC,KAAK;qBACjB,IAAC,CACH;iBACF;aACF,CAAC;YACF,YAAY,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YACjC,OAAO,EAAE,mBAAmB,qBAAA,EAAE,IAAI,eAAO,IAAI,IAAE,SAAS,EAAE,YAAY,GAAE,EAAoB,CAAC;SAC9F;QACH,mCAAC;IAAD,CAhDA,CAA2C,QAAQ,GAgDlD;;IC1BD;;;;IAIA;QAAmCA,wCAAQ;QAmBzC,8BAAY,OAAiC;YAA7C,YACE,kBAAM,OAAO,CAAC,SAOf;YANC,KAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;YACzB,KAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;YAC/B,KAAI,CAAC,WAAW,GAAGC,iBAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YAC9C,KAAI,CAAC,WAAW,GAAGA,iBAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YAC9C,KAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,IAAI,YAAY,CAAC;YAC7D,KAAI,CAAC,mBAAmB,GAAG,OAAO,CAAC,mBAAmB,IAAI,YAAY,CAAC;;SACxE;QAEO,kDAAmB,GAA3B,UAA4B,IAAe;YAA3C,iBAUC;YATC,IAAI,IAAI,CAAC,IAAI,EAAE;gBACb,IAAM,QAAQ,GAAG,CAAC,IAAI,CAAC,SAAS,IAAI,EAAE,EAAE,IAAI,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,KAAI,CAAC,IAAI,GAAA,CAAC,CAAC;gBAClF,IAAI,CAAC,QAAQ;oBAAE,OAAO,SAAS,CAAC;gBAChC,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,KAAK,aAAa,EAAE;oBACzC,OAAO,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK,KAAI,CAAC,OAAO,GAAA,CAAC,CAAC;iBAC/E;aACF;iBAAM;gBACL,OAAO,CAAC,IAAI,CAAC,SAAS,IAAI,EAAE,EAAE,IAAI,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,KAAI,CAAC,OAAO,GAAA,CAAC,CAAC;aAC5E;SACF;QAEM,sCAAO,GAAd,UAAe,WAA2B,EAAE,OAAkB;YAC5D,IAAI,CAAC,iBAAM,OAAO,YAAC,WAAW,EAAE,OAAO,CAAC;gBAAE,OAAO,KAAK,CAAC;YACvD,IAAM,IAAI,GAAG,WAAW,CAAC,IAAiB,CAAC;YACnC,IAAA,qDAAmB,CAAiB;;YAE5C,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO;gBAAE,OAAO,KAAK,CAAC;;YAGxC,IAAI,CAAC,IAAI,CAAC,SAAS;gBAAE,OAAO,KAAK,CAAC;YAElC,IAAM,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAExD,IAAI,CAAC,gBAAgB;gBAAE,OAAO,KAAK,CAAC;;YAGpC,IAAI,gBAAgB,CAAC,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;gBAC9C,IAAM,MAAM,GAAG,gBAAgB,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;;gBAEjD,KAA4B,UAAmB,EAAnB,2CAAmB,EAAnB,iCAAmB,EAAnB,IAAmB,EAAE;oBAA5C,IAAM,aAAa,4BAAA;oBACtB,IAAI,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,MAAM,EAAE;wBAChD,OAAO,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC;qBACzD;iBACF;aACF;;iBAEI;gBACH,IAAM,YAAY,GAAG,gBAAgB,CAAC,KAAK,CAAC;gBAC5C,OAAOC,mBAAW,CAAC,YAAY,CAAC,CAAC;;;;;;;;aAQlC;YAED,OAAO,KAAK,CAAC;SACd;QAEM,2CAAY,GAAnB,UACE,EAAsD,EACtD,SAAoB;YAFtB,iBAgCC;gBA/BG,iBAAa,EAAE,4CAAmB;YAGpC,IAAM,IAAI,GAAG,OAAoB,CAAC;YAClC,IAAM,UAAU,GAAG,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;;YAExD,IAAI,UAAU,EAAE;gBACd,IAAM,UAAU,GAAG,mBAAmB,CAAC,GAAG,CAAC,UAAA,MAAM;oBAC/C,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,UAAU;wBAAE,OAAO,MAAM,CAAC;oBAC7D,oBAAY,MAAM,IAAE,IAAI,EAAE,KAAI,CAAC,WAAW,IAAG;iBAC9C,CAAC,CAAC;gBACH,OAAO,EAAE,IAAI,MAAA,EAAE,mBAAmB,EAAE,UAAU,EAAE,CAAC;aAClD;;YAED,IAAM,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;YACxD,IAAI,IAAI,CAAC,SAAS,IAAI,gBAAgB,EAAE;gBACtC,IAAM,IAAI,GAAO,IAAI,CAAC,SAAS,QAAC,CAAC;gBACjC,IAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,KAAK,EAAE,EAAE,SAAS,WAAA,EAAE,IAAI,MAAA,EAAE,CAAC,CAAC;;;;;;;;;;;gBAWvF,IAAI,QAAQ;oBAAE,MAAM,CAAC,MAAM,CAAC,gBAAgB,EAAE,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC;aACpE;YACD,OAAO,EAAE,IAAI,MAAA,EAAE,mBAAmB,qBAAA,EAAE,CAAC;SACtC;QAEM,+CAAgB,GAAvB,UAAwB,EAAiC,EAAE,SAAoB;gBAArD,iBAAa;;YACrC,IAAM,IAAI,GAAG,OAAoB,CAAC;YAClC,IAAI,CAAC,SAAS;gBAAE,OAAO,SAAS,CAAC;YACjC,IAAM,UAAU,GAAG,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;YACxD,IAAM,IAAI,GAAO,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,EAAE,SAAE,CAAC;YACzD,oBACK,SAAS,GACR,UAAU;4BACR,GAAC,UAAU,IAAG,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,EAAE,SAAS,WAAA,EAAE,IAAI,MAAA,EAAE,CAAC,QAC/E,EAAE,GACN;SACH;QAEO,wDAAyB,GAAjC,UAAkC,IAAe;YAC/C,IAAM,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAE,CAAC;YACzD,IAAM,YAAY,GAAG,gBAAgB,CAAC,KAAqB,CAAC;YAC5D,OAAO,YAAY,CAAC,IAAI,KAAKC,YAAI,CAAC,QAAQ,IAAI,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;SACvE;QACH,2BAAC;IAAD,CArIA,CAAmC,QAAQ,GAqI1C;;ICnKD;;;;IAIA;QAAuCH,4CAAQ;QAI7C,kCAAY,OAAqC;YAAjD,YACE,kBAAM,OAAO,CAAC,SAGf;YAFC,KAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;YAC3C,KAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;;SAC5C;QAEM,0CAAO,GAAd,UAAe,WAA2B,EAAE,OAAkB;YAA9D,iBAiBC;YAhBC,IAAI,CAAC,iBAAM,OAAO,YAAC,WAAW,EAAE,OAAO,CAAC;gBAAE,OAAO,KAAK,CAAC;YACvD,IAAM,IAAI,GAAG,WAAW,CAAC,IAAiB,CAAC;;YAE3C,IAAI,CAAC,IAAI,CAAC,YAAY;gBAAE,OAAO,KAAK,CAAC;;YAErC,IACE,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,CAC/B,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,KAAK,KAAI,CAAC,aAAa,GAAA,CAC9E,EACD;gBACA,OAAO,KAAK,CAAC;aACd;;YAED,OAAO,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,CACxC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,OAAO,IAAI,KAAI,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAA,CACxF,CAAC;SACH;QAEM,+CAAY,GAAnB,UAAoB,cAA8B;YAAlD,iBAuBC;YAtBC,IAAM,IAAI,GAAG,cAAc,CAAC,IAAiB,CAAC;YACtC,IAAA,wDAAmB,CAAoB;YAC/C,IAAI,CAAC,IAAI,CAAC,YAAY;gBAAE,OAAO,cAAc,CAAC;YAC9C,IAAM,aAAa,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,IAAI,EAAE,EAAE,MAAM,CAC/D,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,OAAO,IAAI,KAAI,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAA,CACxF,CAAC;YACF,IAAM,UAAU,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,IAAI,EAAE,EAAE,MAAM,CAC5D,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,OAAO,IAAI,KAAI,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,GAAA,CAC1F,CAAC;YACF,IAAM,YAAY,GAAc;gBAC9B,IAAI,EAAE,OAAO;gBACb,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,aAAa,EAAE;gBACjD,YAAY,EAAE;oBACZ,IAAI,EAAE,cAAc;oBACpB,UAAU,EAAE,aAAa;iBAC1B;aACF,CAAC;YACF,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAC9B,OAAO;gBACL,mBAAmB,qBAAA;gBACnB,IAAI,eAAO,IAAI,IAAE,YAAY,eAAO,IAAI,CAAC,YAAY,IAAE,UAAU,EAAE,UAAU,MAAI;aAChE,CAAC;SACrB;QAEM,kDAAe,GAAtB,UAAuB,QAAa,EAAE,GAAW,EAAE,KAAc;;YAE/D,IAAM,OAAO,GAAG,iBAAM,qBAAqB,YAAC,QAAQ,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YAClE,IAAI,OAAO,KAAK,IAAI,IAAI,OAAO,OAAO,KAAK,QAAQ;gBAAE,OAAO,QAAQ,CAAC;;YAGrE,IAAI,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,OAAO,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,QAAQ,EAAE;gBAClF,IAAM,UAAU,gBAAQ,OAAO,EAAK,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAE,CAAC;gBAClE,OAAO,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;gBAEtC,OAAO,iBAAM,sBAAsB,YAAC,QAAQ,EAAE,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;aACvE;YAED,OAAO,QAAQ,CAAC;SACjB;QACH,+BAAC;IAAD,CArEA,CAAuC,QAAQ,GAqE9C;;IC1ED;;;;IAIA;QAA+CA,oDAAQ;QAGrD,0CAAY,OAA6C;YAAzD,YACE,kBAAM,OAAO,CAAC,SAEf;YADC,KAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;;SAChD;QAEM,kDAAO,GAAd,UAAe,WAA2B,EAAE,OAAkB;YAC5D,IAAI,CAAC,iBAAM,OAAO,YAAC,WAAW,EAAE,OAAO,CAAC;gBAAE,OAAO,KAAK,CAAC;YACvD,IAAM,IAAI,GAAG,WAAW,CAAC,IAAiB,CAAC;;YAE3C,IAAI,IAAI,CAAC,YAAY;gBAAE,OAAO,KAAK,CAAC;YACpC,OAAO,IAAI,CAAC;SACb;QAEM,uDAAY,GAAnB,UAAoB,cAA8B;YAChD,IAAM,IAAI,GAAG,cAAc,CAAC,IAAiB,CAAC;YACtC,IAAA,wDAAmB,CAAoB;;YAE/C,IAAI,IAAI,CAAC,YAAY;gBAAE,OAAO,cAAc,CAAC;YAE7C,IAAM,YAAY,GAAqB;gBACrC,IAAI,EAAE,cAAc;gBACpB,UAAU,EAAE;oBACV;wBACE,IAAI,EAAE,OAAO;wBACb,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,eAAe,EAAE;qBACpD;iBACF;aACF,CAAC;YAEF,OAAO;gBACL,mBAAmB,qBAAA;gBACnB,IAAI,eAAO,IAAI,IAAE,YAAY,cAAA,GAAE;aACd,CAAC;SACrB;QAEM,0DAAe,GAAtB,UAAuB,QAAa,EAAE,GAAW,EAAE,KAAc;;YAE/D,IAAM,OAAO,GAAG,iBAAM,qBAAqB,YAAC,QAAQ,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YAClE,IAAI,OAAO,KAAK,IAAI;gBAAE,OAAO,QAAQ,CAAC;;YAGtC,IAAM,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YACjD,OAAO,iBAAM,sBAAsB,YAAC,QAAQ,EAAE,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;SACvE;QACH,uCAAC;IAAD,CA/CA,CAA+C,QAAQ,GA+CtD;;IC9CD;QAAuDA,6CAAQ;QAG7D,mCAAY,EAA0D;gBAAxD,wBAAS,EAAE,8BAAY;YAArC,YACE,kBAAM,EAAE,SAAS,WAAA,EAAE,CAAC,SAErB;YADC,KAAI,CAAC,YAAY,GAAG,YAAY,CAAC;;SAClC;QAEM,2CAAO,GAAd,UAAe,WAA2B,EAAE,OAAkB;YAC5D,IAAI,CAAC,iBAAM,OAAO,YAAC,WAAW,EAAE,OAAO,CAAC;gBAAE,OAAO,KAAK,CAAC;YACvD,IAAM,IAAI,GAAG,WAAW,CAAC,IAAiB,CAAC;;YAE3C,IAAI,IAAI,CAAC,YAAY;gBAAE,OAAO,KAAK,CAAC;YACpC,OAAO,IAAI,CAAC;SACb;QAEM,gDAAY,GAAnB,UAAoB,cAA8B;YAChD,IAAM,IAAI,GAAG,cAAc,CAAC,IAAiB,CAAC;YACtC,IAAA,wDAAmB,CAAoB;;YAE/C,IAAI,IAAI,CAAC,YAAY;gBAAE,OAAO,cAAc,CAAC;YAE7C,IAAM,YAAY,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAElE,OAAO;gBACL,mBAAmB,qBAAA;gBACnB,IAAI,eAAO,IAAI,IAAE,YAAY,cAAA,GAAE;aACd,CAAC;SACrB;QAEO,wDAAoB,GAA5B,UAA6B,MAAqB;YAAlD,iBAWC;YAVC,OAAO;gBACL,IAAI,EAAE,cAAc;gBACpB,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC,UAAC,EAAmB;wBAAjB,cAAI,EAAE,wBAAS;oBAAO,mBAC9C,IAAI,EAAE,OAAO,EACb,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,KAC/B,SAAS,IAAI;wBACf,YAAY,EAAE,KAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC;qBACnD;iBACD,CAAC;aACgB,CAAC;SACvB;QACH,gCAAC;IAAD,CA1CA,CAAuD,QAAQ,GA0C9D;;IC9CD,IAAM,sBAAsB,GAAG,UAAC,EAIE;YAJF,4BAIE,EAHhC,gCAAa,EACb,gCAAa,EACb,4BAAW;QAEX,OAAO,UAAC,EAAQ,EAAE,OAAO;gBAAf,cAAI;YACZ,IAAM,WAAW,GAAG,OAAO,CAAC,IAAI,CAAC,UAAC,EAAQ;oBAAN,cAAI;gBAAO,OAAA,IAAI,KAAK,oBAAoB;aAAA,CAE/D,CAAC;YACd,IAAI,CAAC,WAAW;gBAAE,OAAO,KAAK,CAAC;YAE/B,IAAI,aAAa,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;gBACpE,OAAO,KAAK,CAAC;aACd;YAED,IAAI,aAAa,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;gBAClF,OAAO,KAAK,CAAC;aACd;YAED,IAAI,WAAW,EAAE;gBACf,IAAM,SAAO,GAAG,WAAW,CAAK,OAAO,SAAE,IAAI,GAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC1D,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAA,SAAS,IAAI,OAAA,SAAS,CAAC,IAAI,CAAC,SAAO,CAAC,GAAA,CAAC,EAAE;oBAC3D,OAAO,KAAK,CAAC;iBACd;aACF;YAED,OAAO,IAAI,CAAC;SACb,CAAC;IACJ,CAAC,CAAC;;IC1BF;AACA,mCAAe,UAAC,EAImB;YAJnB,4BAImB,EAHjC,kCAAc,EACd,kCAAc,EACd,4BAAW;QAEX,OAAO,UAAC,EAAQ,EAAE,OAAO;gBAAf,cAAI;YACZ,IAAM,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,UAAC,EAAQ;oBAAN,cAAI;gBAAO,OAAA,IAAI,KAAK,qBAAqB;aAAA,CAEjE,CAAC;YAEd,IAAI,CAAC,YAAY;gBAAE,OAAO,KAAK,CAAC;YAEhC,IAAI,cAAc,EAAE;gBAClB,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;oBAC3E,OAAO,KAAK,CAAC;iBACd;aACF;YAED,IAAI,cAAc,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,EAAE;gBACtE,OAAO,KAAK,CAAC;aACd;YAED,IAAI,WAAW,EAAE;gBACf,IAAM,SAAO,GAAG,WAAW,CAAK,OAAO,SAAE,IAAI,GAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC1D,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAA,SAAS,IAAI,OAAA,SAAS,CAAC,IAAI,CAAC,SAAO,CAAC,GAAA,CAAC,EAAE;oBAC3D,OAAO,KAAK,CAAC;iBACd;aACF;YAED,OAAO,IAAI,CAAC;SACb,CAAC;IACJ,CAAC,EAAC;;ICpCF,IAAM,mBAAmB,GAAG,UAAC,EAGE;YAHF,4BAGE,EAF7B,0BAAU,EACV,4BAAW;QAEX,OAAO,uBAAuB,CAAC;YAC7B,WAAW,aAAA;YACX,cAAc,EAAE,UAAU;YAC1B,cAAc,EAAE,CAAC,OAAO,CAAC;SAC1B,CAAC,CAAC;IACL,CAAC,CAAC;;ICTF,IAAM,sBAAsB,GAAG,UAAC,EAGE;YAHF,4BAGE,EAFhC,gCAAa,EACb,4BAAW;QAEX,OAAO,uBAAuB,CAAC;YAC7B,WAAW,aAAA;YACX,cAAc,EAAE,aAAa;YAC7B,cAAc,EAAE,CAAC,UAAU,CAAC;SAC7B,CAAC,CAAC;IACL,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;"}